\documentclass[a4paper,UKenglish]{lipics-v2016}
%This is a template for producing LIPIcs articles. 
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
% for section-numbered lemmas etc., use "numberwithinsect"
 
\usepackage{microtype}%if unwanted, comment out or use option "draft"

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the recommended bibstyle

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{The Three-HITs Theorem\footnote{This work was partially supported by COST Action CA15123.}}
\titlerunning{The Three-HITs Theorem} %optional, in case that the title is too long; the running title should fit into the top page column

%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
\author[1]{Andrej Bauer}
\author[2]{Niels van der Weide}
\affil[1]{Department of Mathematics and Physics, University of Ljubljana, Ljubljana, Slovenia\\
  \texttt{Andrej.Bauer@andrej.com}}
\affil[2]{Department of Computer Science, Radboud University, Nijmegen, The Netherlands\\
  \texttt{nweide@cs.ru.nl}}
\authorrunning{A. Bauer and N. van der Weide} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'

\Copyright{Andrej Bauer and Niels van der Weide}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\subjclass{F.4.1 Mathematical Logic}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation". 
\keywords{homotopy type theory, higher inductive types, category theory}% mandatory: Please provide 1-5 keywords
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\usepackage[all,cmtip]{xy}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{thmtools}



\declaretheorem[style=definition,qed=$\blacksquare$]{construction}


\input{coq.sty}
\input{bussproofs.sty}

\newcommand{\Boperator}[1]{\mathrm{\mathbf{#1}}}
\newcommand{\comment}[1]{-- #1 --}
\newcommand{\remove}[1]{}
\newcommand{\inn}{\Boperator{in}}

\newcommand{\conc}[0]{\bullet}
\newcommand{\comp}[0]{\circ \,}

\newcommand{\zero}[0]{\textbf{0}}
\newcommand{\one}[0]{\textbf{1}}
\newcommand{\two}[0]{\textbf{2}}

\newcommand{\frec}[0]{\!\operatorname{rec}}
\newcommand{\rec}[0]{\operatorname{rec}}
\newcommand{\nonrec}[0]{\operatorname{nonrec}}

\newcommand{\ap}[0]{\operatorname{ap}}
\newcommand{\apd}[0]{\operatorname{apD}}

\newcommand{\term}[0]{\textbf{term}}
\newcommand{\Con}[0]{\textbf{Con}}
\newcommand{\Approx}[0]{\textbf{Approx}}

\newcommand{\idmap}[0]{\Boperator{Id}}
\newcommand{\refl}[0]{\Boperator{refl}}
\newcommand{\hpushout}[0]{\Boperator{hpushout}}
\newcommand{\hocolim}[0]{\Boperator{hocolim}}
\newcommand{\seg}[0]{\Boperator{seg}}
\newcommand{\inl}[0]{\Boperator{inl}}
\newcommand{\inr}[0]{\Boperator{inr}}
\newcommand{\glue}[0]{\Boperator{glue}}
\newcommand{\inc}[0]{\Boperator{inc}}
\newcommand{\com}[0]{\Boperator{com}}
\newcommand{\Type}[0]{\operatorname{\textsc{Type}}}
\newcommand{\pt}[0]{*}

\newcommand{\dak}[1]{\widehat{#1}}
\newcommand{\hatt}{\dak{t}}
\newcommand{\hatr}{\dak{r}}


\begin{document}

\maketitle

\begin{abstract}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent convallis orci arcu, eu mollis dolor. Aliquam eleifend suscipit lacinia. Maecenas quam mi, porta ut lacinia sed, convallis ac dui. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti. 
 \end{abstract}

\section{Introduction}
Higher inductive types (HITs) generalize normal inductive types by allowing constructors for both points and paths, rather than just for the points.
While an inductive type is freely generated from a signature, a higher inductive type is freely generated from a signature with some equations.
Numerous examples and definitions of such types have already been given in the literature \cite{altenkirch2016quotient,awodey2012inductive,basoldhigher,sojakova2015higher,hottbook}, but a definition with a good metatheory is still lacking.
As a step towards that goal, we simplify the definition given in \cite{basoldhigher} bringing it closer to the intuition and the intended meaning.

Philosophically, one sees an inductive type as a type `which is built step by step'.
One starts with the nonrecursive constructors, and then at each step new terms are added by applying the recursive constructors to the previously built terms.
This is explained by a theorem which says that inductive types are initial algebras for a functor \cite{dybjer1994inductive,dybjer2003induction} and another one about how these algebras are obtained \cite{adamek1974free}.
For higher inductive types one would expect a similar result which explains how they are constructed.
However, since equations are also allowed in the definition of a higher inductive type, one would expect that during the construction identifications are made by gluing paths.

The goal of this paper is to formally justify this idea by showing that the higher inductive types defined in \cite{basoldhigher} can be generated from the interval, homotopy pushout and colimit.
More concretely, we will prove the following theorem.
\begin{theorem}[Three-HITs Theorem]
\label{thm:three-hit}
In Martin-L\"of Type Theory extended with an interval object, homotopy pushouts and colimits, we can define for each higher inductive type from \cite{basoldhigher} a type with the same introduction, elimination and computation rules.
\end{theorem}
Also, this generalizes the results in \cite{doorn2016constructing,kraus2014general,kraus2016constructions} where the result is showed for truncations.
With this result the metatheory of higher inductive types could be simplified significantly, because rather than a general class, one only needs to check metatheoretical properties for three HITs.

In Section \ref{sec:prelims} we shall recall some of the required material for this paper.
More concretely, we give the syntax of higher inductive types, and using that we define the interval, homotopy pushout, and colimit.
Next we define the approximating sequence of a higher inductive type in Section \ref{sec:approximator}, and in Section \ref{sec:rules} we show that the colimit of this sequence satisfies the rules of the given HIT.
For this we need some lemmata which are proved in Section \ref{sec:Lemmata}.

\section{Preliminaries}
\label{sec:prelims}
Let us briefly recall the scheme of higher inductive types which we shall use \cite{basoldhigher}.
First of all, we need \emph{polynomial functors}.
\begin{definition}
Let $X$ be a variable.
Then a \emph{polynomial} is given by the following grammar.
\[
F, G ::= B : \Type \ | \ X \ | \ F \times G \ | \ F + G
\]
\end{definition}
A possible extension would be to use arbitrary containers as in \cite{abbott2005containers}, but we shall refrain to do so.
With that extension the given proof requires the axiom of choice which generally does not hold in type theory.
One can prove that polynomials are functors, and that given a type family $Y : T \rightarrow \Type$ and a polynomial $F$, we get a lift $\bar{F} : F \> T \rightarrow \Type$.
We will write $F \> f$ to denote the application of a polynomial $F$ to a map $f$.
Also, given a dependent function $f : \prod (x : T), Y \> x$, one can define $\bar{F} \> f : \prod (x : H \> T), \bar{H} \> Y \> x$.
Precise definitions of these are given in \cite{basoldhigher}.

Next we define the notion of a constructor term.
\begin{definition}
Given is a function $c : A \> T \rightarrow T$.
Then we say $t$ is a \emph{constructor term} over $c$ if we can find polynomials $F$ and $G$ such that $x : F \> T \Vdash t : G \> T$ can be derived using the following rules.
\begin{gather*}
	\AxiomC{$t : B$}
	\AxiomC{$T$ does not occur in $B$}
	\BinaryInfC{$x:F \> T \Vdash t : B$}
	\bottomAlignProof
	\DisplayProof 
	 \quad
	\AxiomC{}
	\UnaryInfC{$x : F \> T \Vdash x : F \> T$}
	\bottomAlignProof
	\DisplayProof
	\quad
	\AxiomC{$x : F \> T \Vdash r : A \> T$}
	\UnaryInfC{$x : F \> T \Vdash c \> r : T$}
	\bottomAlignProof
	\DisplayProof
	\\[7pt]
	\AxiomC{$j \in \{1, 2\}$}
	\AxiomC{$x : F \> T \Vdash r : G_1 \> T \times G_2 \> T$}
	\BinaryInfC{$x : F \> T \Vdash\pi_j \> r : G_j \> T$}
	\bottomAlignProof
	\DisplayProof
	\quad
	\AxiomC{$j \in \{1, 2\}$}
	\AxiomC{$x : F \> T \Vdash r_j : G_j$}
	\BinaryInfC{$x : F \> T \Vdash (r_1, r_2) : G_1 \> T\times G_2 \> T$}
	\bottomAlignProof
	\DisplayProof
	\\[7pt]
	\AxiomC{$j \in \{1, 2\}$}
	\AxiomC{$x : F \> T \Vdash r : G_j \> T$}
	\BinaryInfC{$x : F \> T : \inn_j \> r : G_1 \> T + G_2 \> T$}
	\bottomAlignProof
	\DisplayProof
\end{gather*}
\end{definition}

Using constructor terms we give the following scheme of higher inductive types.
\begin{definition}
\label{def:hit}
A \emph{higher inductive type} is defined according to the following scheme
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H$ :=
| $c$ : $A \> H \rightarrow H$
| $p_i$ : $\prod (x : B_i \> H), t_i = r_i$ $\quad (i = 1, \ldots, m)$
\end{lstlisting}
where $A$ and each $B_i$ are polynomials, and each $t_i$ and $r_i$ are constructor terms over $c$ of type $H$ with $x : B_i \> H$ as variable..
\end{definition}

Before we can give the rules for higher inductive types, we need to define the lift of a constructor term.
\begin{definition}
Given is a constructor $c : A \> H \rightarrow H$, a type family $Y : H \rightarrow \Type$, and a term $f : \prod (x: A \> H), \bar{A} \> Y \> x \rightarrow  Y(c \> x)$.
For a constructor term $F \> H \Vdash r : G \> H$ we define the \emph{lift $\dak{r}$ of $r$} with type 
$
x : F \> H, h_x : \bar{F} \> Y \> x \vdash \dak{r} : \bar{G} \> Y \> r
$
by induction in $r$ as follows.
	\begin{align*}
		\dak{t} & := t
		& \dak{x} & := h_x &
		\dak{c_i \> r} & := f_i \> r \> \dak{r}\\
		\dak{\pi_j \> r} & := \pi_j \> \dak{r} &
		\dak{(r_1, r_2)} & := (\dak{r_1}, \dak{r_2})
		& \dak{\inn_j \> r} & := \dak{r}
	\end{align*}
\end{definition}

With all these notions we can give the introduction, elimination and computation rules of higher inductive types.
The introduction rules for $H$ as given in Definition \ref{def:hit} are
\begin{minipage}{0.6\textwidth}
\[
c : A \> H \rightarrow H
\]
\end{minipage}
\begin{minipage}{0.4\textwidth}
\[
p_i : \prod (x : B_i \> H), t_i = r_i.
\]
\end{minipage}
We also have an elimination rule for which we use the lifting of constructor terms.
\begin{equation*}
	\AxiomC{$\vdash Y : H \rightarrow \Type$}
	\noLine
	\UnaryInfC{$\vdash f : \prod (x : A \> H), \bar{A} \> Y \> x \rightarrow Y \> (c \> x)$}
%	\noLine
	\AxiomC{$\vdash q_i : \prod (x : B_i \> H) (h_x : \bar{B}_i \> Y \> x), \hatt_i =_{p_j \, x} \hatr_j$}
	\BinaryInfC{$\vdash H\frec(f, q_1, \ldots, q_n) : \prod (x : H), Y \> x$}
	\DisplayProof
\end{equation*}
Let us abbreviate $H\frec(f, q_1, \ldots, q_n)$ by $H\frec$.
The type $H$ also has computation rules for each point $t : A \> H$
\begin{equation*}
H\frec \> (c \> t) \equiv f \> t \> (\bar{A} \> H\frec \> t),
\end{equation*}
and for each $a : B_i \> H$
\begin{equation*}
\apd \> H\frec \> (p_i \> a) \equiv q_i \> a \> (\bar{B}_i \> H\frec \> a).
\end{equation*}
Note that these equalities are definitional rather than propositional.

Let us now give some examples of higher inductive types which will be crucial in this paper.
The first one would be the interval
\lstset{language=Coq}
\begin{lstlisting}
Inductive $I^1$ :=
| $0$ : $I^1$
| $1$ : $I^1$
| $\seg$ : $0 = 1$
\end{lstlisting}
Note that for every type $A$ with inhabitants $x$ and $y$ we have a path $x = y$ iff we have a map $I^1$ to $A$ sending 0 and 1 to $x$ and $y$ respectively.
Let $\one$ be the unit type with point $\pt$.
Then we can define maps $\delta_0, \delta_1 : \one \rightarrow$ sending $\pt$ to 0 and 1 respectively.
Also, we define the boundary inclusion $\delta : \one + \one \rightarrow I^1$ by $\delta_0 + \delta_1$.

Next we define the homotopy pushout.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\hpushout$ $(A, B, C : \Type)$ $(f : A \rightarrow B)$ $(g : A \rightarrow C)$ :=
| $\inl$ : $B \rightarrow$ $\hpushout$ $A$ $B$ $C$ $f$ $g$
| $\inr$ : $C \rightarrow$ $\hpushout$ $A$ $B$ $C$ $f$ $g$
| $\glue$ : $\prod (a : A), \inl (f \> a) = \inr (g \> a)$
\end{lstlisting}
Note the similarities with the construction of the pushout \cite{mac2013categories}.
Lastly, we can define the homotopy colimit as a higher inductive type in much the same way.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\hocolim$ $(F : \mathbb{N} \rightarrow \Type)$ $(f : \prod (n : \mathbb{N}, F \> n \rightarrow F(n+1)))$ :=
| $\inc$ : $\prod (n : \mathbb{N}), F \> n \rightarrow$ $\hocolim$ $F$ $f$
| $\com$ : $\prod (n : \mathbb{N}) (x : F \> n), \inc \> n \> x = \inc \> (n+1) \> (f \> n \> x)$
\end{lstlisting}

\section{The Approximator}
\label{sec:approximator}
Let us assume that some higher inductive type $H$ is given.
In order to construct $H$ as a colimit, we first need to give the approximations in the colimit, and for that we define the \emph{approximator}.

Before giving the definition, let us think about how it should be given.
By Ad\'amek's theorem, every inductive type can be given as a colimit.
An inductive type $T$ is given by a polynomial functor $F$ and a constructor $c : F \> T \rightarrow T$, and then $T$ is the colimit of the sequence
\[
\xymatrix
{
	\zero \ar[r] & F \> \zero  \ar[r] & F(F \> \zero) \ar[r] & \ldots
}
\]
To understand what this does, let us assume that $F \> X = 1 + X$, so that $T = \mathbb{N}$.
This means we have two inclusions  $\xymatrix{1 \ar[r] & 1+X}$ and  $\xymatrix{X \ar[r] & 1+X}$, and we call them $0_C$ and $S_C$ respectively.
At every step we formally add for each $x : X$ a successor $S_C \> x$, and we add $0_C$.
Repeatedly applying this construction to the empty type $\zero$ gives the natural numbers $\mathbb{N}$.

For higher inductive types one would like to do a similar construction.
The first difference is that instead of starting with nothing and adding each constructor at every step, we start with the nonrecursive constructors, and add recursive constructors at every step.
Also, since extra equalities might be present in the higher inductive type, we need to make identifications during the construction.
Rather than just adding points at every step, we also need to glue the right paths.

To understand what should be done more precisely, let us consider an example.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\mathbb{N}_2$ :=
| $0$ : $\mathbb{N}_2$
| $S$ : $\mathbb{N}_2 \rightarrow \mathbb{N}_2$
| $p$ : $S(S \> 0) = 0$
\end{lstlisting}
The first approximation just has a constructor $0$, and after that we add a constructor for $S \> 0$ to obtain the second approximation.
In the third approximation, which we call $F' \> 3$, we found inhabitants $0$, $S \> 0$, and $S(S \> 0)$, and now we can make the first identification.
To do so, we take the following homotopy pushout
\[
\xymatrix
{
	\one + \one \ar[d]_{0 + S(S \> 0)} \ar[r]^-{\delta} & I^1 \ar[d]\\
	F' \> 3\ar[r] & F \> 3
}
\]
to obtain the actual third approximation $F \> 3$, and we continue our construction with that one.
Note that to glue during the $n$th step, we need refer to elements from the $(n-2)$th step.
So, in order to do the identification of the $n$th step, one needs to refer back to a previous approximation.

Note that one always has to go back a fixed number of steps due to the usage of constructor terms.
By extending the syntax, one can also think of examples where one needs to go back an arbitrary amount of steps.
This happens in the following example.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H$ :=
| $c$ : $H$
| $f$ : $H \rightarrow H$
| $p$ : $\prod (n : \mathbb{N}), f^n \> 0 = 0$
\end{lstlisting}
This example might seem like it is permitted by the syntax, but it is not.
The function $f^n$ is defined as a polymorphic map, and using it requires the type $H$ as an argument.
In constructor terms one cannot use the type, and hence this definition is not allowed
An extension with such types will make the construction more complicated, and thus they will not be considered in this paper.

Let us make this idea formal, and for that we start with a higher inductive type given as follows.
\lstset{language=Coq}
\begin{lstlisting}[label={lst:HIT}]
Inductive $H$ :=
| $c_{\nonrec}$ : $A_{\nonrec} \rightarrow H$
| $c_{\rec}$ : $A_{\rec} \> H \rightarrow H$
| $p_i$ : $\prod (x : B_i \> H), t_i = r_i$ $\quad (i = 1, \ldots, m)$
\end{lstlisting}
Note that the nonrecursive and recursive point constructors are separated in this definition.
The first approximation will be given using the nonrecursive constructors.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H_{\nonrec}$ :=
| $c_{\nonrec}'$ : $A_{\nonrec} \rightarrow H_{\nonrec}$
\end{lstlisting}

Next we need to generate the other approximations, and that will be done in two steps.
First, we note that types can be extended with a recursive constructor.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H_{\rec}$ $(P : \Type)$:=
| $c_{\rec}'$ : $A_{\rec} \> P \rightarrow H_{\rec} \> P$
\end{lstlisting}
To do the identifications, we need to be able to interpret the constructor terms.
For that we use that each constructor terms only uses each constructor  a finite amount of times, and thus there is a maximum number $n \geq 1$ of times a constructor is used.
In order to define the approximator, we start with a type $H_{\Con}^n$ in which all the constructor terms can be interpreted.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H_{\Con}^n$ $(P : \Type)$:=
| $\term$ : $P + H_{\rec} \> P + \ldots + H_{\rec}^n \> P \rightarrow H_{\Con}^n \> P$
\end{lstlisting}

If $n$ is clear from the context, then we shall not write it down.

\begin{lemma}
Suppose, we have a constructor term $t$ such that $x : F \> T \Vdash t : G \>T$ which uses at most $n$ constructors, and that we have a map $c_{\nonrec}' : A_{\nonrec} \rightarrow P$.
Then $t$ induces a map $\overline{t} : F \> P \rightarrow G \> H_{\Con}^n$ by replacing the constructors $c_{\nonrec}$ and $c_{\rec}$ by $c_{\nonrec}'$ and $c_{\rec}'$ respectively.
\end{lemma}

\begin{proof}
We use induction on the form of the constructor term.
\begin{itemize}
	\item $t = a$ with $a : B$ and $B$ does not use $T$. Then we define $\overline{t} \> y = a$.
	\item $t = x$ with $x : F \> T$. Then we define $\overline{t} \> y = \inn_P y$.
	\item $t = c_{\nonrec} a$ with $a : A_{\nonrec}$. Then we define $\overline{t} \> y = c_{\nonrec}' a$.
	\item $t = c_{\rec} r$ with $r : A_{\rec} \> T$ where $r$ uses at most $n-1$ constructors. 
			  By induction we have a map $\overline{r} : F \> P \rightarrow A_{\rec} \> H_{\Con}^{n-1}$.
			  Then we define $\overline{t} \> y = c_{\rec}' (\overline{r} \> x)$.
	\item For the rules for the projection, pairing and injection it is trivial. \qedhere
\end{itemize}
\end{proof}

Now we have enough to define the approximator.
During the construction one also needs to pay attention to coherency.
For example, in $P$ we have terms using $c_{\rec}$ at most $k$ times, so in $H_{\Approx} \> P$ we have duplicates of terms using $c_{\rec}$ less than $k$ times.
There will be several coherency problems during the proof, so the pushout will seem rather intimidating at first.

\begin{definition}
Let a higher inductive type $H$ be given as before, and let the type $H_{\Con}$ be defined as before.
Given are parameters $P$ and $Q$ with amps $i_l : H_{\Con} \> Q \rightarrow P$ and $i_r : I^1 \times B_i \> Q + Q \rightarrow P$.
Let us define the following maps.
\begin{align*}
\widetilde{i_l} &= i_l \comp \inn_1\\
g_1 &: ((\one + \one) \times B_i \> P) + H_{\Con} \> Q  + (I^1 \times B_i \> Q + Q)\rightarrow (I^1 \times B_i \> P) + P\\
g_1 &= (\inn_1 \comp \delta \times \idmap) + (\inn_2 \comp i_l) + (\inn_2 \comp i_r \circ \inn_1)\\
g_2 &: ((\one + \one) \times B_i \> P) + H_{\Con} \> Q + (I^1 \times B_i \> Q + Q) \rightarrow H_{\Con} \> P + (I^1 \times B_i \> P + P)\\
g_2 &= (\inn_1 \comp \overline{t_i} + \overline{r_i})+ (\inn_1 \comp H_{\Con} \> \widetilde{i_l}) + (\inn_2 \comp (I^1 \times B_i \> \widetilde{i_l}))
\end{align*}
Then we define the \emph{approximator} $H_{\Approx}$ of $H$ the following pushout.
\[
\xymatrix
{
	((\one + \one) \times B_i \> P) + H_{\Con} \> Q + (I^1 \times B_i \> Q) 
	\ar[d]_{g_2} 
	\ar[r]^-{g_1}
	& (I^1 \times B_i \> P) + P  
	\ar[d]^-{\inr}\\
	H_{\Con} \> P + (I^1 \times B_i \> P)  
	\ar[r]_-{\inl} 
	& H_{\Approx} \> P \> Q \> i_l \> i_r
}
\]
Note that this can be written as the homotopy pushout.
Often we will suppress the maps from the notation.
\end{definition}

The types $Q$ and $P$ represent $F(n-2)$ and $F(n-1)$ respectively, and the maps $i_l$ and $i_r$ are the inclusion maps into $F(n-1)$.
The new type is extended with constructors and paths given by $\inl \comp \inn_1$ and $\inr \comp \inn_1$ respectively.
Also, there are coherency conditions added and these are given by the second and third component of the left upper corner.
Their use will become clear in the Section \ref{sec:rules} when we show the introduction rules.
Now we can define the approximating sequence.

\begin{definition}
In the setting as described, we simultaneously define a sequence of approximations $F : \mathbb{N} \rightarrow \Type$ to $H$ and maps $f : \prod(n : \mathbb{N}), F \> n \rightarrow F(n+1)$ as follows
\begin{align*}
F \> 0 &= H_{\nonrec},\\
F \> 1 &= H_{\Approx} \> (F \> 0) \> \zero \> (\zero\frec (F \> 0)) \> (\zero\frec (F \> 0))\\
F(n+2) &= H_{\Approx} \> (F(n+1)) \> (F \> n) \> \inl \> \inr \qedhere
\end{align*}
For the maps maps $f \> n : F \> n \rightarrow F(n + 1)$, note that we always have the following sequence of maps
\[
\xymatrix@1
{
	P \ar[r] & (I^1 \times B_i \> P) + P \ar[r] & H_{\Approx} P.
}
\]
Taking $P$ to be $F \> n$, then we have $F (n+1) = H_{\Approx} (F \> n)$, and thus the composition gives the map $F \> n \rightarrow F(n + 1)$.
\end{definition}

\section{The Rules}
\label{sec:rules}
Now we have defined an object $\hocolim \> F \> f$, which is supposed to interpret the higher inductive type.
In order to finish the proof of Theorem \ref{thm:three-hit}, we need to show that it satisfies the rules.
This means that we have to make functions which interpret the introduction rules, and an eliminator such that the computation rules are satisfied.
We will do this step by step, and refer to lemmata in Section \ref{sec:Lemmata} when needed.

\subsection{Introduction Rules}
In order to show that this is the desired type, we first show that it has the correct introduction rules.
These come in three flavors: the nonrecursive and the recursive points, and the paths.

Let us start by defining a map $A_{\nonrec} \rightarrow \hocolim \> F \> f$ which gives the introduction rule for the nonrecursive point constructor.
Since $F \> 0$ is defined by $H_{\nonrec}$, which has a constructor $c'_{\nonrec} : A_{\nonrec} \rightarrow H_{\nonrec}$, this can be defined by the following composition.
\[
\xymatrix
{
	A_{\nonrec} \ar[rr]^-{c'_{\nonrec}}
		& & F \> 0 \ar[rr]^-{\inc \> 0}
		& & \hocolim \> F \> f
}
\]

Next we show that we also have the recursive point constructor meaning that we have a map $A_{\rec} \> (\hocolim \> F \> f) \rightarrow \hocolim \> F \> f$.
This is slightly more complicated, and for that we first need a lemma which says that colimits over $\mathbb{N}$ commute with polynomials.

\begin{lemma}
\label{lem:colim_commute_poly}
The types $A \> (\hocolim \> F \> f)$ and $\hocolim \> (A \comp F) \> (A \> f)$ are isomorphic for all polynomials $A$.
\end{lemma}

\begin{proof}
If $A$ is constant then it follows from Lemma \ref{lem:colimcon}.
For the identity it is trivial, and for sums and products, it follows from Lemmata \ref{lem:colimsum} and \ref{lem:colimprod} respectively. 
\end{proof}

Now we will construct the map $A_{\rec} \> (\hocolim \> F \> f) \rightarrow \hocolim \> F \> f$, and by Lemma \ref{lem:colim_commute_poly} it suffices to make a map $\hocolim \> (A_{\rec} \comp F) \> (A \> f) \rightarrow \hocolim \> F \> f$.
For this we use the recursion rule of $\hocolim$, and we start with the following string of maps
\[
\xymatrix
{
		A_{\rec}(F \> n) \ar[r]^-{c_{\rec}'} 
		& H_{\rec}(F \> n) \ar[rr]^{\term \comp \iota_2} &
		& H_{\Con}(F \> n) \ar[r]^-{\inl}
		& H_{\Approx}(F \> n) = F(n + 1)
}
\]
where the map $H_{\rec}(F \> n) \rightarrow H_{\Con}(F \> n)$ is the inclusion and the map $H_{\Con}(F \> n) \rightarrow H_{\Approx}(F \> n)$ is the pushout map.
Composing this map with $\inc$, gives maps $A_{\rec}(F \> n) \rightarrow \hocolim \> F \> f$ for all $n : \mathbb{N}$.

Next we need to show the commutativity of the following triangle.
\[
\xymatrix
{
	A_{\rec}(F \> n) \ar[rr]^{A_{\rec}(f \> n)} \ar[dr] & & A_{\rec}(F(n+1)) \ar[dl] \\
	& \hocolim \> F \> f &
}
\]
Before we continue, let us recall that inductive types are functors.
Suppose, we have an inductive type $T$ with a parameter $P$, then a function $f : P \rightarrow Q$ gives a function $T \> f : T \> P \rightarrow T \> Q$.
Let us start with the following rectangle
\[
\xymatrix
{
	A_{\rec}(F \> n) \ar[r]^-{c_{\rec}'} \ar[d]_{A_{\rec}(f \> n)} 
		& H_{\rec}(F \> n) \ar[rr]^{\term \comp \iota_2} \ar[d]_{H_{\rec}(f \> n)} &
		& H_{\Con}(F \> n) \ar[d]_{H_{\Con}(f \> n)}\\
	A_{\rec}(F(n+1)) \ar[r]_-{c_{\rec}'} 
		& H_{\rec}(F(n+1)) \ar[rr]_{\term \comp \iota_2} &
		& H_{\Con}(F(n+1))
}
\]
The left square commutes, because by definition of $H_{\rec} \> f$ we have
\[
H_{\rec} \>(f \> n) \> (c_{\rec}' x) = c_{\rec}' (A_{\rec} \> (f \> n) \> x).
\]
For a similar reason the right triangle commutes as well.
Hence, it suffices to show that the following diagram commutes.
\[
\xymatrix
{
	H_{\Con}(F \> n) \ar[d]_{H_{\Con} \> (f \> n)} \ar[r]^-{\inl}
		& F(n+1) \ar[d]^{f(n+1)}\\
	H_{\Con}(F(n+1)) \ar[r]_-{\inl}
		& H_{\Approx} \> (F(n+1)) \> (F \> n)
}
\]
Note that $H_{\Approx}(F(n+1)) = F(n+2)$ and $H_{\Approx}(F \> n) = F(n+1)$.
Hence, this diagram commutes, because of the pushout we used to define $H_{\Approx}$.

Next we need to define the introduction rules for the paths.
Let us start by making maps $I^1 \times B_i \> (\hocolim \> F \> f) \rightarrow \hocolim \> F \> f$.
Since homotopy colimits commute with polynomials, it suffices to make a map $\hocolim \> (I^1 \times B_i \> F) \> (I^1 \> B_i \> f)  \rightarrow \hocolim \> F \> f$.

For this we use the eliminator of the homotopy colimit.
First, we need to make for all $n$ a map $I^1 \times B_i \> (F \> n)  \rightarrow \hocolim \> F \> f$.
By definition we have the following string of maps
\[
\xymatrix
{
	I^1 \times B_i \> (F \> n) \ar[r]^-{\inn_1} & I^1 \times B_i \> (F \> n) + F \> n \ar[r]^-{\inr}& F(n+1) \ar[rr]^-{\inc(n+1)} & & \hocolim \> F \> f.
}
\]
Next we need to show that the following diagram commutes.
\[
\xymatrix
{
	I^1 \times B_i \> (F \> n) \ar[r]^-{\inn_1} \ar[d]_{I^1 \times B_i \> (f \> n)} & I^1 \times B_i \> (F \> n) + F \> n \ar[r]^-{\inr} \ar[d]_{I^1 \times B_i \> (f \> n) + f \> n} & F(n+1) \ar[d]^{f(n+1)}\\
	I^1 \times B_i \> (F(n+1)) \ar[r]_-{\inn_1} & I^1 \times B_i \> (F(n+1)) + F(n+1) \ar[r]_-{\inr}& F(n+2) 
}
\]
Note that the left diagram commutes.
For the right diagram we can unpack the definition of $f(n+1)$.
\[
\xymatrix
{
	I^1 \times B_i \> (F \> n) + F \> n \ar[r]^-{\inr} \ar[d]_{I^1 \times B_i \> (f \> n) + f \> n} & F(n+1) \ar[d]^{f(n+1)} \ar[dl]^{\inn_2}\\
	I^1 \times B_i \> (F(n+1)) + F(n+1) \ar[r]_-{\inr}& F(n+2) 
}
\]
On the first coordinate it commutes by definition and on the second it commutes by how $F(n+2)$ was defined.


Now we check that the defined paths have the right endpoints, and for that we look at the following diagram.
\[
\xymatrix
{
	2 \times B_i(\hocolim \> F \> f) \ar[r] \ar[dr]_{\overline{t_i} + \overline{r_i}} & I^1 \times B_i(\hocolim \> F \> f) \ar[r] & \hocolim \> (I^1 \times B_i \> F) \> (I^1 \times B_i \> f) \ar[dl]\\
	& \hocolim \> F \> f
}
\]

$2 \times B_i(\hocolim \> F \> f)$ is isomorphic to $\hocolim \> (2 \times B_i \> F) \> 2 (\times B_i \> f)$.

Induction to second, so we have $(0, x)$ (similar for $1$) and $x : F \> n$.
This gets mapped to $(0, x)$ which is equal to $t_i$ via the path $\glue (\inl (0, x))$.

Remaining:
\begin{equation*}
\begin{split}
\com_*(\ap \> (\inc \> n) \> \glue (\inl (0, x))) = \ap \> (\inc (n+1))) \>\glue (\inl (0, f \> n \> x))\\
(\ap \> \overline{t_i} \> \com)^{-1} \conc \ap \> (\inc \> n) \> \glue (\inl (0, x)) \conc \ap \> p_i \> \com
\end{split}
\end{equation*}
$(\ap \> \overline{t_i} \> \com)^{-1}$ is like $\ap \> (\inc \> n) \> (\ap \> c \> \ldots (\ldots \ap \> \text{coherence path}))$, because of the computation rule of $c_i$.

This is the coherence path which should be added on level $n$.


\subsection{Elimination Rule}
For the next step we define the right eliminator for $\hocolim \> F \> f$, so suppose that we are given
\[
Y : \hocolim \> F \> f \rightarrow \Type,
\]
\[
c_{Y, \nonrec} : \prod (a : A_{\nonrec}), Y(c_{\nonrec} \> a),
\]
\[
c_{Y, \rec} : \prod (x : A_{\rec} \> \hocolim \> F \> f), \overline{A_{\rec}} \> Y \> x \rightarrow Y(c_{\rec} \> x),
\]
\[
q_{Y, i} : \prod (x : B_i \> H)(h_x : \overline{B_i} \> Y \> x), \hatt_i =_{p_j \, x} \hatr_j.
\]
In order to make a map $h : \prod (x : \hocolim \> F \> f), Y \> x$, we use the induction principle of $\hocolim \> F \> f$, and for that we first need to make maps $h \> n : \prod (x : F \> n), Y(\inc \> n \> x)$ for $n : \mathbb{N}$.

We start by making a map $h \> 0 : \prod (x : F \> 0), Y(\inc \> 0 \> x)$.
Recall that $F \> 0$ was defined to be $H_{\nonrec}$ which only has a constructor $c'_{\nonrec} : A_{\nonrec} \rightarrow H_{\nonrec}$.
So, let us assume that we have $a : A_{\nonrec}$.
Since $c_{\nonrec} \> a = \inc \> 0 \> (c_{\nonrec}' \> a)$, it suffices to find an inhabitant of $Y(c_{\nonrec} \> a)$, and for that we take $c_{Y, \nonrec} \> a$.
Hence, we get a map $h \> 0$.

Now suppose that we have a map $h \> n : \prod (x : F \> n), Y(\inc \> n \> x)$, and our goal is to make a map $h(n+1) : \prod  (x : F(n+1)), Y(\inc \> (n+1) \> x)$.
In order to do so, we will first look at how to extend $h \> n$ to a map $\prod (x : H_{\Con} (F \> n)), Y(\inc \> (n+1) \> (\inl \> x))$.

Let us do this in the general case.
Suppose, we have a map $g : P \rightarrow \hocolim \> F \> f$, and that we already constructed $\varphi : \prod (x : P), Y(g \> x)$.
Our goal is to extended the map into a $\varphi' : \prod (x : H_{\rec} P), Y(c_{Y, \rec} \> x)$, and for that we use $H_{\rec}$-induction.
Note that for each $c'_{\rec} \> x$ with $x : A_{\rec} \> P$ we have the type $Y(c_{\rec} \> (A_{\rec} \> g \> x))$, and thus we have a type family on $H_{\rec}$.
Now let $x : A_{\rec} \> P$ and $y : \overline{A_{\rec}} \> Y \> x$ be given.
Then we need to give an element of the type $Y(c_{\rec} \> (A_{\rec} \> g \> x))$ for which we take $c_{Y,\rec} \> (A_{\rec} \> g \> x) \> y$.

Now we can also extend the map to $H_{\Con}^n \> P$, because we can define this map on each component.
On the component $P$ it is just $\varphi$, and on the other components we define it via extension.

Next we need to extend the map to $H_{\Approx} \> P \> Q$.
This is done by the universal mapping property of the pushout, and that requires two steps.
First, we need to extend the map to $I^1 \times B_i \> P$, and second we need to check that the diagram given by the pushout commutes.
For that we start with $(y, x) : I^1 \times B_i \> P$, and we use $I^1$-induction.
If $y = 0$, we map it to $\hatt_i (x)$, and for $y = 1$ we map it to $\hatr_i (x)$.
Now the path $q_{Y, i}$ gives the image of $\seg$, and that finishes the induction.

Since $H_{\Approx}$ is a pushout, we also need to show that a diagram commutes.
The left upper corner is defined to be a sum, and thus it suffices to check it for each of the components.
For the first, $H_{\Con} \> P$, note that the map $\varphi'$ to $Y$ defined by extension, sends the constructor term $t_i$ to its lift $\hatt_i$, since it replaces each $c_{\rec}$ by $c_{Y, \rec}$.
On $I^1 \times B_i \> P$ the points are mapped to the lifts $\hatt_i$ as well, and thus the diagram commutes on this component.

Next we do it for the coherency condition on the points where we look at the following corner
\[
\xymatrix
{
	H_{\Con}(F \> n) \ar[r]^{\inl} \ar[d]_{H_{\Con} (f \> n)} & F(n+1)\\
	H_{\Con} (F(n+1))
}
\]
Elements of $H_{\Con}(F \> n)$ are terms built from $c_{\rec}$ on $F \> n$.
In order to show that it commutes for all inhabitants of $H_{\Con}(F \> n)$, we use induction on the depth.
If the inhabitant is of the form $\inn_1 \> x$ with $x : F \> n$, then it gets mapped to the first component of $H_{\Con} (F(n+1))$ and $F(n+1)$.
In both cases it is just mapped with $h \> (n+1)$ and thus they are equal.

To show that it holds for the other inhabitants as well, we take a look at $c_{\rec}' \> x$.
By $\inl$ it gets mapped $\inl (c_{\rec}' \> x)$.
Since $h(n+1)$ is defined as the pushout map, it maps $\inl (c_{\rec}' \> x)$ to $h \> (n+1) \> (c_{\rec}' \> x) \equiv c_{Y, \rec}(h \> n \> x)$.
The map $H_{\Con} (f \> n)$ sends $c_{\rec}' \> x$ to $c_{\rec}' (f \> n \> x)$, and the dependent map $h$ sends it to $c_{Y, \rec}(h \> (n+1) \> (f \> x))$.
Using the definition of the pushout map, this is equal to $c_{Y, \rec}(h \> n \> x)$
Hence, this diagram commutes, and thus the first coherency is fine.

Now we also need to check the second coherency, and then we look at another corner
\[
\xymatrix
{
	I^1 \times B_i (F \> n) \ar[rr]^-{\inr \circ \inn_1} \ar[d]_{I^1 \times B_i \inl} & & F(n+1)\\
	I^1 \times B_i(F(n+1)) 
}
\]
Let $(y, x) : I^1 \times B_i (F \> n)$.
Note that 
\[
h \> (n+1) \> (\inr(\inn_1 (y, x))) = h \> n \> (\inn_1 (y, x)) = \overline{q_{Y, i}}(y, h \> n \> x).
\]
\[
h \> (n+1) \> (I^1 \times B_i \> \inl \> (y, x)) = h \> (n+1) \> (y, \inl x) = \overline{q_{Y, i}}(y, h \> (n+1) \> (\inl \> x)) = \overline{q_{Y, i}}(y, h \> n \> x).
\]
Hence, this coherency is fine as well.




To finish the proof, we need to give the image for the path $\com$.
More concretely, we need to show that $\inc \> n \> x$ and $\inc \> (n+1) \> (f \> x)$ are mapped to the same element.
The map $f : F \> n \rightarrow F(n + 1)$ is defined by the pushout as follows
\[
\xymatrix
{
	((\one + \one) \times B_i \> (F(n+1))) + H_{\Con} \>  (F \> n) \ar[d]_{\overline{t_i} + \overline{r_i} + H_{\Con} \> f} \ar[rr]^-{\delta + \inl} & & (I^1 \times B_i \> (F(n+1))) + F(n+1)  \ar[d]^{\inr}\\
	H_{\Con} \> (F(n+1)) \ar[rr]_{\inl} & & F(n+2)
}
\]
Since the map to $Y$ was defined as the pushout map, it will commute automatically.

All in all, we have acquired a map $\prod (x : \hocolim \> F \> f), Y \> x$, and this way we defined the right eliminator for $\hocolim \> F \> f$.
We shall call the eliminator $H\frec$.

\subsection{Computation Rules}
Lastly, we show that this eliminator also satisfies the computation rules.
First, we prove that for each $t : A_{\rec}(\hocolim \> F \> f)$ that $H\frec(c_{\rec} \> t) \equiv f_i \> t \> (\overline{A_{\rec}} \> H\frec \> t)$.
Again we use that colimits commute with polynomials.

Let $n : \mathbb{N}$ and $x : A_{\rec}(F \> n)$.
Then by the computation rules we have
\begin{equation*}
\begin{split}
H\frec(c_{\rec} \> x) 
&\equiv H\frec(\inc \> (n+1) \> (c_{\rec}' x)) \\
&\equiv c_{Y,\rec} \> (A_{\rec} \> (\inc \> n) \> x) \> (\overline{A} \> H\frec \> x)\\
\end{split}
\end{equation*}
Hence, we can always take $\refl$ to be the path.
This will also give an image for $\com$, and thus the computation rules for the points are satisfied.

Note that the this computation rule is a propositional equality.
This is logical, because it is proven all $x : A_{\rec}(F \> n)$.
However, for closed terms, we have a definitional equality.
This is because $c_{\nonrec} \> a$ for $a : A_{\nonrec}$ is defined to be$\inc \> 0 \> (c_{\nonrec}' \> a)$.
All the closed terms are thus inhabitants of some $F \> n$, and since at every step the equalities are definitional, we can conclude that for closed terms the equality is definitional.

Now we show the computation rules for the paths, and in that case we have a parameter $a : B_i \> (\hocolim \> F \> f)$.
By using that polynomials commute with homotopy colimits, we can again assume that we have $n : \mathbb{N}$ and $x : B_i(F \> n)$.
\begin{equation*}
\begin{split}
\apd \> H\frec \> (p_i \> (\inc \> n \> x))
&\equiv \apd \> H\frec \> (\apd \> (\inc (n+1)) \> (\inr \> x))\\
&= \apd \> (H\frec \comp  \> \inc (n+1)) \> (\inr \> x))\\
&\equiv q_i \> (H\frec x)
\end{split}
\end{equation*}


\section{Lemmata}
\label{sec:Lemmata}
In this section we proof the required lemmata to show that colimits over $\mathbb{N}$ commute with polynomials.
In category theory this result is standard \cite{mac2013categories}.

\begin{lemma}
\label{lem:colimcon}
$\hocolim \> (\lambda n . A) \> (\lambda n . \operatorname{Id})$ is isomorphic to $A$.
\end{lemma}

\begin{proof}
We define $f : A \rightarrow \hocolim \> (\lambda n . A) \> (\lambda n . \operatorname{Id})$ to be $\inc \> 0$.
Next we define $g : \hocolim \> (\lambda n . A) \> (\lambda n . \operatorname{Id}) \rightarrow A$ by $\hocolim$ recursion.
We send $\inc \> n \> a$ to $a$, and then the required diagrams commute by reflexivity.
For the proof that it these maps are mutual inverses, we refer the reader to the accompanying Coq code \cite{CoqImpl}.
\end{proof}

\begin{lemma}
\label{lem:colimsum}
Colimits commute with coproducts.
\end{lemma}

\begin{lemma}
\label{lem:colimprod}
Colimits commute with products.
\end{lemma}

\section{Conclusion and Further Work}



\nocite{*}

%%
%% Bibliography
%%

%% Either use bibtex (recommended), 

\bibliography{lipics-v2016-sample-article}

%% .. or use the thebibliography environment explicitely



\end{document}
