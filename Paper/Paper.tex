\documentclass[a4paper,UKenglish]{lipics-v2016}
%This is a template for producing LIPIcs articles. 
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
% for section-numbered lemmas etc., use "numberwithinsect"
 
\usepackage{microtype}%if unwanted, comment out or use option "draft"

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the recommended bibstyle

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{The Three-HITs Theorem\footnote{This work was partially supported by COST Action CA15123.}}
\titlerunning{The Three-HITs Theorem} %optional, in case that the title is too long; the running title should fit into the top page column

%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
\author[1]{Andrej Bauer}
\author[2]{Niels van der Weide}
\affil[1]{Department of Mathematics and Physics, University of Ljubljana, Ljubljana, Slovenia\\
  \texttt{Andrej.Bauer@andrej.com}}
\affil[2]{Department of Computer Science, Radboud University, Nijmegen, The Netherlands\\
  \texttt{nweide@cs.ru.nl}}
\authorrunning{A. Bauer and N. van der Weide} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'

%\Copyright{Andrej Bauer and Niels van der Weide}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\subjclass{F.4.1 Mathematical Logic}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation". 
\keywords{homotopy type theory, higher inductive types, category theory}% mandatory: Please provide 1-5 keywords
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\usepackage[all,cmtip]{xy}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{thmtools}



\declaretheorem[style=definition,qed=$\blacksquare$]{construction}


\input{coq.sty}
\input{bussproofs.sty}

\newcommand{\comment}[1]{-- #1 --}
\newcommand{\remove}[1]{}
\newcommand{\inn}{{\rm in}}

\newcommand{\conc}[0]{\bullet}

\newcommand{\zero}[0]{\textbf{0}}
\newcommand{\one}[0]{\textbf{1}}
\newcommand{\two}[0]{\textbf{2}}

\newcommand{\frec}[0]{\!\operatorname{rec}}
\newcommand{\rec}[0]{\operatorname{rec}}
\newcommand{\nonrec}[0]{\operatorname{nonrec}}

\newcommand{\ap}[0]{\operatorname{ap}}
\newcommand{\apd}[0]{\operatorname{apd}}

\newcommand{\term}[0]{\textbf{term}}
\newcommand{\Con}[0]{\textbf{Con}}
\newcommand{\Approx}[0]{\textbf{Approx}}

\newcommand{\refl}[0]{\operatorname{\textbf{refl}}}
\newcommand{\hpushout}[0]{\operatorname{\textbf{hpushout}}}
\newcommand{\hocolim}[0]{\operatorname{\textbf{hocolim}}}
\newcommand{\seg}[0]{\operatorname{\textbf{seg}}}
\newcommand{\inl}[0]{\operatorname{\textbf{inl}}}
\newcommand{\inr}[0]{\operatorname{\textbf{inr}}}
\newcommand{\glue}[0]{\operatorname{\textbf{glue}}}
\newcommand{\inc}[0]{\operatorname{\textbf{inc}}}
\newcommand{\com}[0]{\operatorname{\textbf{com}}}
\newcommand{\Type}[0]{\operatorname{\textsc{Type}}}
\newcommand{\pt}[0]{*}

\newcommand{\dak}[1]{\widehat{#1}}
\newcommand{\hatt}{\dak{t}}
\newcommand{\hatr}{\dak{r}}


\begin{document}

\maketitle

\begin{abstract}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent convallis orci arcu, eu mollis dolor. Aliquam eleifend suscipit lacinia. Maecenas quam mi, porta ut lacinia sed, convallis ac dui. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti. 
 \end{abstract}

\section{Introduction}
Higher inductive types (HITs) extend normal inductive types by allowing constructors for both points and paths, rather than just for the points.
While inductive types are freely generated from a signature, a higher inductive type is freely generated from a signature with equations.
Numerous examples and definitions of such types have been given in the literature \cite{altenkirch2016quotient,awodey2012inductive,basoldhigher,sojakova2015higher,hottbook}, but a definition with a good metatheory remains to be given.
As a step towards that goal, we simplify the definition given in \cite{basoldhigher} bringing it closer to the intuition and the intended meaning.

Philosophically, one sees an inductive type as a type `which is built step by step'.
One starts with the nonrecursive constructors, and then at each step new terms are added by applying the recursive constructors to the previously built terms.
This is explained by a theorem which says that inductive types are initial algebras for a functor \cite{dybjer1994inductive,dybjer2003induction} and another one about how these algebras are obtained \cite{adamek1974free}.
For higher inductive types one would expect a similar result which explains philosophically what they are.
The only difference between higher inductive types and normal inductive types is that during the construction of higher inductive types several identifications are made which are described by the path constructors.

The goal of this paper is to show that the higher inductive types defined in \cite{basoldhigher} can be generated from the interval, homotopy pushouts and colimits, and that formally justifies this intuition on higher inductive types.
More concretely, we will prove the following theorem.
\begin{theorem}[Three-HITs Theorem]
\label{thm:three-hit}
In Martin-L\"of Type Theory extended with an interval object, homotopy pushouts and colimits, we can define for each higher inductive type as in \cite{basoldhigher} a tye with the same introduction, elimination and computation rules.
\end{theorem}
Also, this generalizes the results in \cite{doorn2016constructing,kraus2014general,kraus2016constructions} where the result is showed for truncations.
With this result the metatheory of higher inductive types could be simplified significantly, because rather than a general class, one only needs to check metatheoretical properties for three types.

In Section \ref{sec:prelims} we shall discuss some of the required notions for this paper.
More concretely, we recall the syntax of higher inductive types, and as examples we give the interval, the homotopy pushout, and colimit.
Next we define the approximating sequence of a higher inductive type in Section \ref{sec:approximator}, and in Section \ref{sec:rules} we show that the colimit of this sequence satisfies the rules of the given HIT.
For this we need some lemmata which are proved in Section \ref{sec:Lemmata}.

\section{Preliminaries}
\label{sec:prelims}
Let us briefly recall the scheme of higher inductive types which we shall use \cite{basoldhigher}.
First of all, we need \emph{polynomial functors}.
\begin{definition}
Let $X$ be a variable.
Then a \emph{polynomial} is given by the following grammar.
\[
F, G ::= B : \Type \ | \ X \ | \ F \times G \ | \ F + G
\]
\end{definition}
A possible extension would be to use arbitrary containers as in \cite{abbott2005containers}, but we shall refrain to do so.
With that extension the given proof requires the axiom of choice which generally does not hold in type theory.
One can prove that polynomials are functors, and that given a type family $Y : T \rightarrow \Type$ and a polynomial $F$, we get a lift $\bar{F} : F \> T \rightarrow \Type$.
We will write $F \> f$ to denote the application of a polynomial $F$ to a map $f$.
Also, given $f : \prod (x : T), Y \> x$, one can define $\bar{F} \> f : \prod (x : H \> T), \bar{H} \> Y \> x$.
Precise definitions of these are given in \cite{basoldhigher}.

Next we define the notion of a constructor term.
\begin{definition}
Given are functions $c : A \> T \rightarrow T$.
Then we say $t$ is a \emph{constructor term} over $c$ if we can find polynomials $F$ and $G$ such that $x : F \> T \Vdash t : G \> T$ can be derived using the following rules.
\begin{gather*}
	\AxiomC{$t : B$}
	\AxiomC{$T$ does not occur in $B$}
	\BinaryInfC{$x:F \> T \Vdash t : B$}
	\bottomAlignProof
	\DisplayProof 
	 \quad
	\AxiomC{}
	\UnaryInfC{$x : F \> T \Vdash x : F \> T$}
	\bottomAlignProof
	\DisplayProof
	\quad
	\AxiomC{$x : F \> T \Vdash r : A \> T$}
	\UnaryInfC{$x : F \> T \Vdash c \> r : T$}
	\bottomAlignProof
	\DisplayProof
	\\[7pt]
	\AxiomC{$j \in \{1, 2\}$}
	\AxiomC{$x : F \> T \Vdash r : G_1 \> T \times G_2 \> T$}
	\BinaryInfC{$x : F \> T \Vdash\pi_j \> r : G_j \> T$}
	\bottomAlignProof
	\DisplayProof
	\quad
	\AxiomC{$j \in \{1, 2\}$}
	\AxiomC{$x : F \> T \Vdash r_j : G_j$}
	\BinaryInfC{$x : F \> T \Vdash (r_1, r_2) : G_1 \> T\times G_2 \> T$}
	\bottomAlignProof
	\DisplayProof
	\\[7pt]
	\AxiomC{$j \in \{1, 2\}$}
	\AxiomC{$x : F \> T \Vdash r : G_j \> T$}
	\BinaryInfC{$x : F \> T : \inn_j \> r : G_1 \> T + G_2 \> T$}
	\bottomAlignProof
	\DisplayProof
\end{gather*}
\end{definition}

Using constructor terms we give the following scheme of higher inductive types.
\begin{definition}
\label{def:hit}
A \emph{higher inductive type} is defined according to the following scheme
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H$ :=
| $c$ : $A \> H \rightarrow H$
| $p_i$ : $\prod (x : B_i \> H), t_i = r_i$ $\quad (i = 1, \ldots, m)$
\end{lstlisting}
where $A$ and each $B_i$ are polynomials, and each $t_i$ and $r_i$ are constructor terms over $c$ of type $H$ with $x : B_i \> H$ as variable..
\end{definition}

Before we can give the rules for higher inductive types, we need to define the lift of a constructor term.
\begin{definition}
Given are a constructor $c : A \> H \rightarrow H$, a type family $Y : H \rightarrow \Type$, and a term
\[
 \vdash f : \prod (x: A \> H), \bar{A} \> Y \> x \rightarrow  Y(c \> x).
\]
For a constructor term $F \> H \Vdash r : G \> H$ we define the \emph{lift $\dak{r}$ of $r$} with type
\[
 x : F \> H, h_x : \bar{F} \> Y \> x \vdash \dak{r} : \bar{G} \> Y \> r
\]
by induction in $r$ as follows.
	\begin{align*}
		\dak{t} & := t
		& \dak{x} & := h_x &
		\dak{c_i \> r} & := f_i \> r \> \dak{r}\\
		\dak{\pi_j \> r} & := \pi_j \> \dak{r} &
		\dak{(r_1, r_2)} & := (\dak{r_1}, \dak{r_2})
		& \dak{\inn_j \> r} & := \dak{r}
	\end{align*}
\end{definition}

With all these notions we can give the introduction, elimination and computation rules of higher inductive types.
The introduction rules for $H$ as given in Definition \ref{def:hit} are
\[
c : A \> H \rightarrow H,
\]
\[
p_i : \prod (x : B_i \> H), t_i = r_i.
\]
We also have an elimination rule for which we use the lifting of constructor terms.
\begin{equation*}
	\AxiomC{$\vdash Y : H \rightarrow \Type$}
	\noLine
	\UnaryInfC{$\vdash f : \prod (x : A \> H), \bar{A} \> Y \> x \rightarrow Y \> (c \> x)$}
%	\noLine
	\AxiomC{$\vdash q_i : \prod (x : B_i \> H) (h_x : \bar{B}_i \> Y \> x), \hatt_i =_{p_j \, x} \hatr_j$}
	\BinaryInfC{$\vdash H\frec(f, q_1, \ldots, q_n) : \prod (x : H), Y \> x$}
	\DisplayProof
\end{equation*}
Let us abbreviate $H\frec(f, q_1, \ldots, q_n)$ by $H\frec$.
The type $H$ also has computation rules for each point $t : A \> H$
\begin{equation*}
H\frec \> (c_i \> t) \equiv f_i \> t \> (\bar{A} \> H\frec \> t),
\end{equation*}
and for each $a : B_i \> H$
\begin{equation*}
\apd \> H\frec \> (p_j \> a) \equiv q_j \> a \> (\bar{B}_i \> H\frec \> a).
\end{equation*}
Note that these equalities are definitional rather than propositional.

Let us finish by defining some examples of higher inductive types which will be used a lot in this paper.
The first one would be the interval
\lstset{language=Coq}
\begin{lstlisting}
Inductive $I^1$ :=
| $0$ : $I^1$
| $1$ : $I^1$
| $\seg$ : $0 = 1$
\end{lstlisting}
Note that for every type $A$ with inhabitants $x$ and $y$ we have a path $x = y$ iff we have a map $I^1$ to $A$ sending 0 and 1 to $x$ and $y$ respectively.
Let $\one$ be the unit type with point $\pt$.
Then we can define maps $\delta_0, \delta_1 : \one \rightarrow$ sending $\pt$ to 0 and 1 respectively.
Also, we define $\delta : \one + \one \rightarrow I^1$ by $\delta_0 + \delta_1$.

Next we define the homotopy pushout.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\hpushout$ $(A, B, C : \Type)$ $(f : A \rightarrow B)$ $(g : A \rightarrow C)$ :=
| $\inl$ : $B \rightarrow$ $\hpushout$ $A$ $B$ $C$ $f$ $g$
| $\inr$ : $C \rightarrow$ $\hpushout$ $A$ $B$ $C$ $f$ $g$
| $\glue$ : $\prod (a : A), \inl (f \> a) = \inr (g \> a)$
\end{lstlisting}
Note the similarities with the construction of the pushout.
Also, we can define the homotopy colimit as a higher inductive type in much the same way.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\hocolim$ $(F : \mathbb{N} \rightarrow \Type)$ $(f : \prod (n : \mathbb{N}, F \> n \rightarrow F(n+1)))$ :=
| $\inc$ : $\prod (n : \mathbb{N}), F \> n \rightarrow$ $\hocolim$ $F$ $f$
| $\com$ : $\prod (n : \mathbb{N}) (x : F \> n), \inc \> n \> x = \inc \> (n+1) \> (f \> n \> x)$
\end{lstlisting}

\section{The Approximator}
\label{sec:approximator}
Let us assume that some higher inductive type $H$ is given.
In order to construct $H$ as a colimit, we first need to give the approximations in the colimit, and for that we define the \emph{approximator}.

Before giving the definition, let us think about how it should be given.
By Ad\'amek's theorem, every inductive type can be given as a colimit.
An inductive type $T$ is given by a polynomial functor $F$ and a constructor $c : F \> T \rightarrow T$, and then $T$ is the colimit of the sequence
\[
\xymatrix
{
	\zero \ar[r] & F \> \zero  \ar[r] & F(F \> \zero) \ar[r] & \ldots
}
\]
To understand what this does, let us assume that $F \> X = 1 + X$, so that $T = \mathbb{N}$.
This means we have two inclusions  $\xymatrix{1 \ar[r] & 1+X}$ and  $\xymatrix{X \ar[r] & 1+X}$, and we call them $0_C$ and $S_C$ respectively.
At every step we formally add for each $x : X$ a successor $S_C \> x$, and we add $0_C$.
Repeatedly applying this construction to the empty type $\zero$ gives the natural numbers $\mathbb{N}$.

For higher inductive types one would like to do a similar construction.
The first difference is that instead of starting with nothing and adding each constructor at every step, we start with the nonrecursive constructors, and add recursive constructors at every step.
Also, since extra equalities might be present in the higher inductive type, we need to make identifications during the construction.
Rather than just adding points at every step, we also need to glue the right paths.

To understand what should be done more precisely, let us consider an example.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\mathbb{N}_2$ :=
| $0$ : $\mathbb{N}_2$
| $S$ : $\mathbb{N}_2 \rightarrow \mathbb{N}_2$
| $p$ : $S(S \> 0) = 0$
\end{lstlisting}
The first approximation just has a constructor $0$, and after that we add a constructor for $S \> 0$ to obtain the second approximation.
In the third approximation, which we call $F \> 3$, we found inhabitants $0$, $S \> 0$, and $S(S \> 0)$, and now we can make the first identification.
To do so, we take the following homotopy pushout
\[
\xymatrix
{
	\one + \one \ar[d]_{0 + S(S \> 0)} \ar[r]^-{\delta} & I^1 \ar[d]\\
	F \> 3\ar[r] & P \> 3
}
\]
to obtain the actual third approximation $P \> 3$, and we continue our construction with that one.
Note that to glue during the $n$th step, we need refer to elements from the $(n-2)$th step.
So, in order to do the identification of the $n$th step, one needs to refer back to a previous approximation.

Note that one always has to go back a fixed number of steps due to the usage of constructor terms.
By extending the syntax, one can also think of examples where one needs to go back an arbitrary amount of steps.
For that, we consider the following example.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\mathbb{N}_2$ :=
| $0$ : $\mathbb{N}_2$
| $S$ : $\mathbb{N}_2 \rightarrow \mathbb{N}_2$
| $p$ : $\prod (n : \mathbb{N}), S^n \> 0 = 0$
\end{lstlisting}
This example might seem like it is allowed in the syntax, but it is not.
The term $S^n$ is defined as a polymorphic function which needs the type as argument, and that is not allowed with constructor terms.
In this extension the construction will be more complicated, and the construction is not predicative, so this will not be considered in this paper.

Let us make this idea formal, and for that we start with a higher inductive type which is given as follows.
\lstset{language=Coq}
\begin{lstlisting}[label={lst:HIT}]
Inductive $H$ :=
| $c_{\nonrec}$ : $A_{\nonrec} \rightarrow H$
| $c_{\rec}$ : $A_{\rec} \> H \rightarrow H$
| $p_i$ : $\prod (x : B_i \> H), t_i = r_i$ $\quad (i = 1, \ldots, m)$
\end{lstlisting}
Note that the nonrecursive and recursive point constructors are separated in this definition.
The first approximation will be given using the nonrecursive constructors.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H_{\nonrec}$ :=
| $c_{\nonrec}'$ : $A_{\nonrec} \rightarrow H_{\nonrec}$
\end{lstlisting}

Next we need to generate the other approximations, and that will be done in two steps.
First, we note that types can be extended with a recursive constructor.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H_{\rec}$ $(P : \Type)$:=
| $c_{\rec}'$ : $A_{\rec} \> P \rightarrow H_{\rec} \> P$
\end{lstlisting}
To do the identifications, we need to be able to interpret the constructor terms.
For that we use that each constructor terms only uses each constructor  a finite amount of times, and thus there is a maximum number $n \geq 1$ of times a constructor is used.
In order to define the approximator, we start with a type $H_{\Con}^n$ in which all the constructor terms can be interpreted.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H_{\Con}^n$ $(P : \Type)$:=
| $\term$ : $P + H_{\rec} \> P + \ldots + H_{\rec}^n \> P \rightarrow H_{\Con} \> P$
\end{lstlisting}

If $n$ is clear from the context, then we shall not write it down.

\begin{lemma}
Suppose, we have a constructor term $t$ such that $x : F \> T \Vdash t : G \>T$ which uses at most $n$ constructors, and that we have a map $c_{\nonrec}' : A_{\nonrec} \rightarrow P$.
Then $t$ induces a map $\overline{t} : F \> P \rightarrow G \> H_{\Con}^n$ by replacing the constructors $c_{\nonrec}$ and $c_{\rec}$ by $c_{\nonrec}'$ and $c_{\rec}'$ respectively.
\end{lemma}

\begin{proof}
We use induction on the form of the constructor term.
\begin{itemize}
	\item $t = a$ with $a : B$ and $B$ does not use $T$. Then we define $\overline{t} \> y = a$.
	\item $t = x$ with $x : F \> T$. Then we define $\overline{t} \> y = \inn_P y$.
	\item $t = c_{\nonrec} a$ with $a : A_{\nonrec}$. Then we define $\overline{t} \> y = c_{\nonrec}' a$.
	\item $t = c_{\rec} r$ with $r : A_{\rec} \> T$ where $r$ uses at most $n-1$ constructors. 
			  By induction we have a map $\overline{r} : F \> P \rightarrow A_{\rec} \> H_{\Con}^{n-1}$.
			  Then we define $\overline{t} \> y = c_{\rec}' (\overline{r} \> x)$.
	\item For the rules for the projection, pairing and injection it is trivial. \qedhere
\end{itemize}
\end{proof}

Now we have enough to define the approximator.
During the construction one also needs to pay attention to coherency.
For example, in $P$ we have $c_{\nonrec}$, so in $H_{\Approx} \> P$ we might have duplicates of some terms.
By tweaking the pushout a little bit, one can easily solve these coherency problems.

\begin{definition}
Let a higher inductive type $H$ be given as before, and let the type $H_{\Con}$ be defined as before.
Then we define the \emph{approximator} $H_{\Approx}$, which has a parameters $P, Q$ and $f : Q \rightarrow P$, of $H$ the following pushout
\[
\xymatrix
{
	((\one + \one) \times B_i \> P) + H_{\Con} \> Q \ar[d]_{\overline{t_i} + \overline{r_i} + H_{\Con} \> f} \ar[rr]^-{\delta + \inl} & & (I^1 \times B_i \> P) + H_{\Approx} Q  \ar[d]^{\inr}\\
	H_{\Con} \> P \ar[rr]_{\inl} & & H_{\Approx} \> P
}
\]
Note that this can be written as the homotopy pushout.
\end{definition}

\begin{definition}
In the setting as described, we simultaneously define a sequence of approximations $F : \mathbb{N} \rightarrow \Type$ to $H$ and maps $f : \prod(n : \mathbb{N}), F \> n \rightarrow F(n+1)$ as follows
\begin{align*}
F \> 0 &= H_{\nonrec},\\
F \> 1 &= H_{\Approx} \> (F \> 0) \> \zero \> (\zero\frec (F \> 0))\\
F(n+2) &= H_{\Approx} \> (F(n+1)) \> (F \> n) \> (f \> n) \qedhere
\end{align*}
For the maps maps $f \> n : F \> n \rightarrow F(n + 1)$, note that we always have the following sequence of maps
\[
\xymatrix@1
{
	P \ar[r] & H_{\Con} \> P \ar[r] & H_{\Approx} P.
}
\]
Taking $P$ to be $F \> n$, then we have $F (n+1) = H_{\Approx} (F \> n)$, and thus the composition gives the map $F \> n \rightarrow F(n + 1)$.
\end{definition}

\section{The Rules}
\label{sec:rules}
Now we have defined an object $\hocolim \> F \> f$, which is supposed to interpret the higher inductive type.
In order to finish the proof of Theorem \ref{thm:three-hit}, we need to show that it satisfies the rules.
This means that we have to make functions which interpret the introduction rules, and an eliminator such that the computation rules are satisfied.
We will do this step by step, and refer to lemmata in Section \ref{sec:Lemmata} when needed.

\subsection{Introduction Rules}
In order to show that this is the desired type, we first show that it has the correct introduction rules.
These come in three flavors: the nonrecursive and the recursive points, and the paths.

Let us start by defining a map $A_{\nonrec} \rightarrow \hocolim \> F \> f$ which gives the introduction rule for the nonrecursive point constructor.
Since $F \> 0$ is defined by $H_{\nonrec}$, which has a constructor $c'_{\nonrec} : A_{\nonrec} \rightarrow H_{\nonrec}$, this can be defined by the following composition.
\[
\xymatrix
{
	A_{\nonrec} \ar[rr]^-{c'_{\nonrec}}
		& & F \> 0 \ar[rr]^-{\inc \> 0}
		& & \hocolim \> F \> f
}
\]

Next we show that we also have the recursive point constructor meaning that we have a map $A_{\rec} \> (\hocolim \> F \> f) \rightarrow \hocolim \> F \> f$.
This is slightly more complicated, and for that we first need a lemma which says that colimits over $\mathbb{N}$ commute with polynomials.

\begin{lemma}
\label{lem:colim_commute_poly}
The types $A \> (\hocolim \> F \> f)$ and $\hocolim \> (A \circ F) \> (A \> f)$ are isomorphic for all polynomials $A$.
\end{lemma}

\begin{proof}

\end{proof}

Now we will construct the map $A_{\rec} \> (\hocolim \> F \> f) \rightarrow \hocolim \> F \> f$, and by Lemma \ref{lem:colim_commute_poly} it suffices to make a map $\hocolim \> (A_{\rec} \circ F) \> (A \> f) \rightarrow \hocolim \> F \> f$.
For this we use the recursion rule of $\hocolim$, and we start with the following string of maps
\[
\xymatrix
{
		A_{\rec}(F \> n) \ar[r]^-{c_{\rec}'} 
		& H_{\rec}(F \> n) \ar[rr]^{\term \circ \iota_2} &
		& H_{\Con}(F \> n) \ar[r]^-{\inl}
		& H_{\Approx}(F \> n) = F(n + 1)
}
\]
where the map $H_{\rec}(F \> n) \rightarrow H_{\Con}(F \> n)$ is the inclusion and the map $H_{\Con}(F \> n) \rightarrow H_{\Approx}(F \> n)$ is the pushout map.
Composing this map with $\inc$, gives maps $A_{\rec}(F \> n) \rightarrow \hocolim \> F \> f$ for all $n : \mathbb{N}$.

Next we need to show the commutativity of the following triangle.
\[
\xymatrix
{
	A_{\rec}(F \> n) \ar[rr]^{A_{\rec}(f \> n)} \ar[dr] & & A_{\rec}(F(n+1)) \ar[dl] \\
	& \hocolim \> F \> f &
}
\]
Before we continue, let us recall that inductive types are functors.
Suppose, we have an inductive type $T$ with a parameter $P$, then a function $f : P \rightarrow Q$ gives a function $T \> f : T \> P \rightarrow T \> Q$.
Let us start with the following rectangle
\[
\xymatrix
{
	A_{\rec}(F \> n) \ar[r]^-{c_{\rec}'} \ar[d]_{A_{\rec}(f \> n)} 
		& H_{\rec}(F \> n) \ar[rr]^{\term \circ \iota_2} \ar[d]_{H_{\rec}(f \> n)} &
		& H_{\Con}(F \> n) \ar[d]_{H_{\Con}(f \> n)}\\
	A_{\rec}(F(n+1)) \ar[r]_-{c_{\rec}'} 
		& H_{\rec}(F(n+1)) \ar[rr]_{\term \circ \iota_2} &
		& H_{\Con}(F(n+1))
}
\]
The left square commutes, because by definition of $H_{\rec} \> f$ we have
\[
H_{\rec} \>(f \> n) \> (c_{\rec}' x) = c_{\rec}' (A_{\rec} \> (f \> n) \> x).
\]
For a similar reason the right triangle commutes as well.
Hence, it suffices to show that the following diagram commutes.
\[
\xymatrix
{
	H_{\Con}(F \> n) \ar[d]_{H_{\Con} \> (f \> n)} \ar[r]^-{\inl}
		& H_{\Approx}(F \> n) \ar[d]^{f(n+1)}\\
	H_{\Con}(F(n+1)) \ar[r]_-{\inl}
		& H_{\Approx}(F(n+1))
}
\]
Note that $H_{\Approx}(F(n+1)) = F(n+2)$ and $H_{\Approx}(F \> n) = F(n+1)$.
Hence, this diagram commutes, because of the pushout.

Next we need to define the introduction rules for the paths.
Let us start by making a map $\sum_{i = 1}^m I^1 \times B_i \> (\hocolim \> F \> f) \rightarrow \hocolim \> F \> f$.
Since homotopy colimits commute with polynomials, it suffices to make a map $\hocolim \> (I^1 \times B_i \> F) \> (I^1 \> B_i \> f)  \rightarrow \hocolim \> F \> f$.

For this we use the eliminator of the homotopy colimit.
First, we need to make for all $n$ a map $I^1 \times B_i \> (F \> n)  \rightarrow \hocolim \> F \> f$.
By definition we have the following string of maps
\[
\xymatrix
{
	I^1 \times B_i \> (F \> n) \ar[rr]^-{\inr} & & F(n+1) \ar[rr]^-{\inc(n+1)} & & \hocolim \> F \> f.
}
\]
Next we need to show that the following diagram commutes.
\[
\xymatrix
{
	I^1 \times B_i \> (F \> n) \ar[rr]^-{\inr} \ar[d]_{I^1 \times B_i \> (f \> n)} & & F(n+1) \ar[d]^{f(n+1)}\\
	I^1 \times B_i \> (F(n+1)) \ar[rr]^-{\inr} & & F(n+2)
}
\]
This can be proven by induction on $B_i$, and using the definition of $I^1 \times B_i \> (f \> n)$.
We can use the path $\refl$.
All in all, we get a map $p_i : \hocolim \> (I^1 \times B_i \> F) \> (I^1 \times B_i \> f) \rightarrow \hocolim \> F \> f$

Now we have the following diagram
\[
\xymatrix
{
	2 \times B_i(\hocolim \> F \> f) \ar[r] \ar[dr]_{\overline{t_i} + \overline{r_i}} & I^1 \times B_i(\hocolim \> F \> f) \ar[r] & \hocolim \> (I^1 \times B_i \> F) \> (I^1 \times B_i \> f) \ar[dl]\\
	& \hocolim \> F \> f
}
\]

$2 \times B_i(\hocolim \> F \> f)$ is isomorphic to $\hocolim \> (2 \times B_i \> F) \> 2 (\times B_i \> f)$.

Induction to second, so we have $(0, x)$ (similar for $1$) and $x : F \> n$.
This gets mapped to $(0, x)$ which is equal to $t_i$ via the path $\glue (\inl (0, x))$.

Remaining:
\begin{equation*}
\begin{split}
\com_*(\ap \> (\inc \> n) \> \glue (\inl (0, x))) = \ap \> (\inc (n+1))) \>\glue (\inl (0, f \> n \> x))\\
(\ap \> \overline{t_i} \> \com)^{-1} \conc \ap \> (\inc \> n) \> \glue (\inl (0, x)) \conc \ap \> p_i \> \com
\end{split}
\end{equation*}
$(\ap \> \overline{t_i} \> \com)^{-1}$ is like $\ap \> (\inc \> n) \> (\ap \> c \> \ldots (\ldots \ap \> \text{coherence path}))$, because of the computation rule of $c_i$.

This is the coherence path which should be added on level $n$.


\subsection{Elimination Rule}
For the next step we define the right eliminator for $\hocolim \> F \> f$. 
For this we suppose that we have
\[
Y : \hocolim \> F \> f \rightarrow \Type
\]
\[
c_{Y, \nonrec} : \prod (a : A_{\nonrec}), Y(c_{\nonrec})
\]
\[
c_{Y, \rec} : \prod (x : A_{\rec} \> \hocolim \> F \> f), \overline{A_{\rec}} \> Y \> x \rightarrow Y(c_{\rec} \> x)
\]
\[
q_{Y, i} : \prod (x : B_i \> H)(h_x : \overline{B_i} \> Y \> x), \hatt_i =_{p_j \, x} \hatr_j
\]
In order to make a map $\prod (x : \hocolim \> F \> f), Y \> x$, we use the induction principle of $\hocolim \> F \> f$, and for that we need to make maps $\prod (x : F \> n), Y(\inc \> n \> x)$.

First we need to make a map $\prod (x : F \> 0), Y(\inc \> 0 \> x)$.
Recall that $F \> 0$ was defined to be $H_{\nonrec}$ which only has a constructor $c'_{\nonrec} : A_{\nonrec} \rightarrow H_{\nonrec}$.
So, let us assume that we have $a : A_{\nonrec}$.
Since $c_{\nonrec} \> a = \inc \> 0 \> (c\_{\nonrec} a)$, it suffices to find an inhabitant of $Y(c_{\nonrec} \> a)$, and for that we take $c_{Y, \nonrec} \> a$.
Hence, we get a map $\prod (x : F \> 0), Y(\inc \> 0 \> x)$.

Now suppose that we have a map $\prod (x : F \> n), Y(\inc \> n \> x)$, and our goal is to make a map $\prod  (x : F(n+1)), Y(\inc \> (n+1) x)$.
In order to do so, we will first look at how to extend it to a map $\prod (x : H_{\Con} (F \> n)), Y(\inc \> (n+1) \> (\inl \> x))$.

Let us do this in the general case.
Suppose that we have $g : P \rightarrow \hocolim \> F \> f$, and that we have $h : \prod (x : P), Y(g \> x)$.
Our goal is to extended the map into a $h' : \prod (x : H_{\rec} P), Y(c_{Y, \rec} \> x)$, and for that we use $H_{\rec}$ induction.
Note that for each $c'_{\rec} \> x$ with $x : A_{\rec} \> P$ we have the type $Y(c_{\rec} \> (A_{\rec} \> g \> x))$, and thus we have a type family on $H_{\rec}$.
Now let $x : A_{\rec} \> P$ and $y : \overline{A_{\rec}} \> Y \> x$ be given.
Then we need to give an element of the type $Y(c_{\rec} \> (A_{\rec} \> g \> x))$ for which we take
\[
c_{Y,\rec} \> (A_{\rec} \> g \> x) \> y
\]
Now we can also extend the map to $H_{\Con}^n \> P$, because we can define this map on each component.
On the component $P$ it is just $h$, and on the other components we define it via extension.

Next we need to extend the map to $H_{\Approx} \> P \> Q$.
For that we need to make a map $h' : \prod (x : I^1 \times B_i \> P), Y()$

Let $(t, x) : I^1 \times B_i \> P$, and now we use $I^1$ induction.
If $t = 0$, we map it to $\hatt_i (x)$, and for $t = 1$ we map it to $\hatr_i (x)$.
Now the path $q_{Y, i}$ gives the image of $\seg$, and that finishes the induction.

For the commutativity of the diagram note that by definition the dependent map from $H_{\Con} \> P$ to $Y$ sends the constructor term $t_i$ to the lift $\hatt_i$.
This is because the map replaces each $c_{\rec}$ by $c_{Y, \rec}$ which is precisely how the lift was constructed.


Next we do it for the coherency.

Induction on the level (so, ultimately some kind of simultaneous induction?)

Then induction on the depth.

Base case: just induction assumption.

Step case: then it can be worked out from the diagram.



To finish the proof, we need to give the image for the path $\com$.
More concretely, we need to show that $\inc \> n \> x$ and $\inc \> (n+1) \> (f \> x)$ are mapped to the same element.
The map $f : F \> n \rightarrow F(n + 1)$ is defined by the pushout as follows
\[
\xymatrix
{
	((\one + \one) \times B_i \> (F(n+1))) + H_{\Con} \>  (F \> n) \ar[d]_{\overline{t_i} + \overline{r_i} + H_{\Con} \> f} \ar[rr]^-{\delta + \inl} & & (I^1 \times B_i \> (F(n+1))) + F(n+1)  \ar[d]^{\inr}\\
	H_{\Con} \> (F(n+1)) \ar[rr]_{\inl} & & F(n+2)
}
\]
Since the map to $Y$ was defined as the pushout map, it will commute automatically.

All in all, we have acquired a map $\prod (x : \hocolim \> F \> f), Y \> x$, and this way we defined the right eliminator for $\hocolim \> F \> f$.
We shall call the eliminator $H\frec$.

\subsection{Computation Rules}
Lastly, we show that this eliminator also satisfies the computation rules.
First, we prove that for each $t : A_{\rec}(\hocolim \> F \> f)$ that $H\frec(c_{\rec} \> t) \equiv f_i \> t \> (\overline{A_{\rec}} H\frec t)$.
Again we use that colimits commute with polynomials.

Let $n : \mathbb{N}$ and $x : A_{\rec}(F \> n)$.
Then by the computation rules we have
\begin{equation*}
\begin{split}
H\frec(c_{\rec} \> x) 
&\equiv H\frec(\inc \> (n+1) \> (c_{\rec}' x)) \\
&\equiv c_{Y,\rec} \> (A_{\rec} \> (\inc \> n) \> x) \> (\overline{A} \> H\frec \> x)\\
\end{split}
\end{equation*}
Hence, we can always take $\refl$ to be the path.
This will also give an image for $\com$, and thus the computation rules for the points are satisfied.

Note that the this computation rule is a propositional equality.
This is logical, because it is proven all $x : A_{\rec}(F \> n)$.
However, for closed terms, we have a definitional equality.
This is because $c_{\nonrec} \> a$ for $a : A_{\nonrec}$ is defined to be$\inc \> 0 \> (c_{\nonrec}' \> a)$.
All the closed terms are thus inhabitants of some $F \> n$, and since at every step the equalities are definitional, we can conclude that for closed terms the equality is definitional.

Now we show the computation rules for the paths.


\section{Lemmata}
\label{sec:Lemmata}

\begin{lemma}
$\hocolim \> (\lambda n . A) \> \operatorname{Id}$ is $A$.
\end{lemma}

\begin{lemma}
Colimits commute with coproducts.
\end{lemma}

\begin{lemma}
Colimits commute with products.
\end{lemma}

\section{Conclusion and Further Work}



\nocite{*}

%%
%% Bibliography
%%

%% Either use bibtex (recommended), 

\bibliography{lipics-v2016-sample-article}

%% .. or use the thebibliography environment explicitely



\end{document}
