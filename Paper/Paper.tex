\documentclass[a4paper,UKenglish]{lipics-v2016}
%This is a template for producing LIPIcs articles. 
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
% for section-numbered lemmas etc., use "numberwithinsect"
 
\usepackage{microtype}%if unwanted, comment out or use option "draft"

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the recommended bibstyle

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{The Three-HIT Theorem\footnote{This work was partially supported by COST Action CA15123.}}
\titlerunning{The Three-HIT Theorem} %optional, in case that the title is too long; the running title should fit into the top page column

%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
\author[1]{Andrej Bauer}
\author[2]{Niels van der Weide}
\affil[1]{Department of Mathematics and Physics, University of Ljubljana, Ljubljana, Slovenia\\
  \texttt{Andrej.Bauer@andrej.com}}
\affil[2]{Department of Computer Science, Radboud University, Nijmegen, The Netherlands\\
  \texttt{nweide@cs.ru.nl}}
\authorrunning{A. Bauer and N. van der Weide} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'

%\Copyright{Andrej Bauer and Niels van der Weide}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\subjclass{F.4.1 Mathematical Logic}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation". 
\keywords{homotopy type theory, higher inductive types, category theory}% mandatory: Please provide 1-5 keywords
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\usepackage[all,cmtip]{xy}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{thmtools}



\declaretheorem[style=definition,qed=$\blacksquare$]{construction}


\input{coq.sty}
\input{bussproofs.sty}

\newcommand{\comment}[1]{-- #1 --}
\newcommand{\remove}[1]{}
\newcommand{\inn}{{\rm in}}

\newcommand{\zero}[0]{\textbf{0}}
\newcommand{\one}[0]{\textbf{1}}
\newcommand{\two}[0]{\textbf{2}}

\newcommand{\frec}[0]{\!\operatorname{rec}}
\newcommand{\rec}[0]{\operatorname{rec}}
\newcommand{\nonrec}[0]{\operatorname{nonrec}}

\newcommand{\ap}[0]{\operatorname{ap}}
\newcommand{\apd}[0]{\operatorname{apd}}

\newcommand{\term}[0]{\textbf{term}}
\newcommand{\Con}[0]{\textbf{Con}}
\newcommand{\Approx}[0]{\textbf{Approx}}

\newcommand{\hpushout}[0]{\operatorname{\textbf{hpushout}}}
\newcommand{\hocolim}[0]{\operatorname{\textbf{hocolim}}}
\newcommand{\seg}[0]{\operatorname{\textbf{seg}}}
\newcommand{\inl}[0]{\operatorname{\textbf{inl}}}
\newcommand{\inr}[0]{\operatorname{\textbf{inr}}}
\newcommand{\glue}[0]{\operatorname{\textbf{glue}}}
\newcommand{\inc}[0]{\operatorname{\textbf{inc}}}
\newcommand{\com}[0]{\operatorname{\textbf{com}}}
\newcommand{\Type}[0]{\operatorname{\textsc{Type}}}
\newcommand{\pt}[0]{*}

\newcommand{\dak}[1]{\widehat{#1}}
\newcommand{\hatt}{\dak{t}}
\newcommand{\hatr}{\dak{r}}


\begin{document}

\maketitle

\begin{abstract}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent convallis orci arcu, eu mollis dolor. Aliquam eleifend suscipit lacinia. Maecenas quam mi, porta ut lacinia sed, convallis ac dui. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti. 
 \end{abstract}

\section{Introduction}
Higher inductive types (HITs) extend normal inductive types by allowing constructors for both points and paths, rather than just for the points.
While inductive types are freely generated from a signature, a higher inductive type is freely generated from a signature with equations.
Numerous examples and definitions of such types have been given in the literature \cite{altenkirch2016quotient,awodey2012inductive,basoldhigher,sojakova2015higher,hottbook}, but a definition with a good metatheory remains to be given.
As a step towards that goal, we simplify the definition given in \cite{basoldhigher} bringing it closer to the intuition and the intended meaning.

Philosophically, one sees an inductive type as a type `which is built step by step'.
One starts with the nonrecursive constructors, and then at each step new terms are added by applying the recursive constructors to the previously built terms.
This is explained by a theorem which says that inductive types are initial algebras for a functor \cite{dybjer1994inductive,dybjer2003induction} and another one about how these algebras are obtained \cite{adamek1974free}.
For higher inductive types one would expect a similar result which explains philosophically what they are.
The only difference between higher inductive types and normal inductive types is that during the construction of higher inductive types several identifications are made which are described by the path constructors.

The goal of this paper is to show that the higher inductive types defined in \cite{basoldhigher} can be generated from the interval, homotopy pushouts and colimits, and that formally justifies this intuition on higher inductive types, 
Also, this generalizes the results in \cite{doorn2016constructing,kraus2014general,kraus2016constructions} where the result is showed for truncations.
With this result the metatheory of higher inductive types could be simplified significantly, because rather than a general class, one only needs to check metatheoretical properties for three types.

In Section \ref{sec:prelims} we shall discuss some of the required notions for this paper.
More concretely, we recall the syntax of higher inductive types, and as examples we give the interval, the homotopy pushout, and colimit.
Next we define the approximating sequence of a higher inductive type in Section \ref{sec:approximator}, and in Section \ref{sec:rules} we show that the colimit of this sequence satisfies the rules of the given HIT.
For this we need some lemmata which are proved in Section \ref{sec:Lemmata}.

\section{Preliminaries}
\label{sec:prelims}
Let us briefly recall the scheme of higher inductive types which we shall use \cite{basoldhigher}.
First of all, we need \emph{polynomial functors}.
\begin{definition}
Let $X$ be a variable.
Then a \emph{polynomial} is given by the following grammar.
\[
F, G ::= B : \Type \ | \ X \ | \ F \times G \ | \ F + G
\]
\end{definition}
A possible extension would be to use arbitrary containers as in \cite{abbott2005containers}, but we shall refrain to do so.
With that extension the given proof requires the axiom of choice which generally does not hold in type theory.
One can prove that polynomials are functors, and that given a type family $Y : T \rightarrow \Type$ and a polynomial $F$, we get a lift $\bar{F} : F \> T \rightarrow \Type$.
We will write $F \> f$ to denote the application of a polynomial $F$ to a map $f$.
Also, given $f : \prod (x : T), Y \> x$, one can define $\bar{F} \> f : \prod (x : H \> T), \bar{H} \> Y \> x$.
Precise definitions of these are given in \cite{basoldhigher}.

Next we define the notion of a constructor term.
\begin{definition}
Given are functions $c : A \> T \rightarrow T$.
Then we say $t$ is a \emph{constructor term} over $c$ if we can find polynomials $F$ and $G$ such that $x : F \> T \Vdash t : G \> T$ can be derived using the following rules.
\begin{gather*}
	\AxiomC{$t : B$}
	\AxiomC{$T$ does not occur in $B$}
	\BinaryInfC{$x:F \> T \Vdash t : B$}
	\bottomAlignProof
	\DisplayProof 
	 \quad
	\AxiomC{}
	\UnaryInfC{$x : F \> T \Vdash x : F \> T$}
	\bottomAlignProof
	\DisplayProof
	\quad
	\AxiomC{$x : F \> T \Vdash r : A \> T$}
	\UnaryInfC{$x : F \> T \Vdash c \> r : T$}
	\bottomAlignProof
	\DisplayProof
	\\[7pt]
	\AxiomC{$j \in \{1, 2\}$}
	\AxiomC{$x : F \> T \Vdash r : G_1 \> T \times G_2 \> T$}
	\BinaryInfC{$x : F \> T \Vdash\pi_j \> r : G_j \> T$}
	\bottomAlignProof
	\DisplayProof
	\quad
	\AxiomC{$j \in \{1, 2\}$}
	\AxiomC{$x : F \> T \Vdash r_j : G_j$}
	\BinaryInfC{$x : F \> T \Vdash (r_1, r_2) : G_1 \> T\times G_2 \> T$}
	\bottomAlignProof
	\DisplayProof
	\\[7pt]
	\AxiomC{$j \in \{1, 2\}$}
	\AxiomC{$x : F \> T \Vdash r : G_j \> T$}
	\BinaryInfC{$x : F \> T : \inn_j \> r : G_1 \> T + G_2 \> T$}
	\bottomAlignProof
	\DisplayProof
\end{gather*}
\end{definition}

Using constructor terms we give the following scheme of higher inductive types.
\begin{definition}
\label{def:hit}
A \emph{higher inductive type} is defined according to the following scheme
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H$ :=
| $c$ : $A \> H \rightarrow H$
| $p_i$ : $\prod (x : B_i \> H), t_i = r_i$ $\quad (i = 1, \ldots, m)$
\end{lstlisting}
where $A$ and each $B_i$ are polynomials, and each $t_i$ and $r_i$ are constructor terms over $c$ of type $H$ with $x : B_i \> H$ as variable..
\end{definition}

Before we can give the rules for higher inductive types, we need to define the lift of a constructor term.
\begin{definition}
Given are a constructor $c : A \> H \rightarrow H$, a type family $Y : H \rightarrow \Type$, and a term
\[
 \vdash f : \prod (x: A \> H), \bar{A} \> Y \> x \rightarrow  Y(c \> x).
\]
For a constructor term $F \> H \Vdash r : G \> H$ we define the \emph{lift $\dak{r}$ of $r$} with type
\[
 x : F \> H, h_x : \bar{F} \> Y \> x \vdash \dak{r} : \bar{G} \> Y \> r
\]
by induction in $r$ as follows.
	\begin{align*}
		\dak{t} & := t
		& \dak{x} & := h_x &
		\dak{c_i \> r} & := f_i \> r \> \dak{r}\\
		\dak{\pi_j \> r} & := \pi_j \> \dak{r} &
		\dak{(r_1, r_2)} & := (\dak{r_1}, \dak{r_2})
		& \dak{\inn_j \> r} & := \dak{r}
	\end{align*}
\end{definition}

With all these notions we can give the introduction, elimination and computation rules of higher inductive types.
The introduction rules for $H$ as given in Definition \ref{def:hit} are
\[
c : A \> H \rightarrow H,
\]
\[
p_i : \prod (x : B_i \> H), t_i = r_i.
\]
We also have an elimination rule for which we use the lifting of constructor terms.
\begin{equation*}
	\AxiomC{$\vdash Y : H \rightarrow \Type$}
	\noLine
	\UnaryInfC{$\vdash f : \prod (x : A \> H), \bar{A} \> Y \> x \rightarrow Y \> (c \> x)$}
%	\noLine
	\AxiomC{$\vdash q_i : \prod (x : B_i \> H) (h_x : \bar{B}_i \> Y \> x), \hatt_i =_{p_j \, x} \hatr_j$}
	\BinaryInfC{$\vdash H\frec(f, q_1, \ldots, q_n) : \prod (x : H), Y \> x$}
	\DisplayProof
\end{equation*}
Let us abbreviate $H\frec(f, q_1, \ldots, q_n)$ by $H\frec$.
The type $H$ also has computation rules for each point $t : A \> H$
\begin{equation*}
H\frec \> (c_i \> t) \equiv f_i \> t \> (\bar{A} \> H\frec \> t),
\end{equation*}
and for each $a : B_i \> H$
\begin{equation*}
\apd \> H\frec \> (p_j \> a) \equiv q_j \> a \> (\bar{B}_i \> H\frec \> a).
\end{equation*}
Note that these equalities are definitional rather than propositional.

Let us finish by defining some examples of higher inductive types which will be used a lot in this paper.
The first one would be the interval
\lstset{language=Coq}
\begin{lstlisting}
Inductive $I^1$ :=
| $0$ : $I^1$
| $1$ : $I^1$
| $\seg$ : $0 = 1$
\end{lstlisting}
Note that for every type $A$ with inhabitants $x$ and $y$ we have a path $x = y$ iff we have a map $I^1$ to $A$ sending 0 and 1 to $x$ and $y$ respectively.
Let $\one$ be the unit type with point $\pt$.
Then we can define maps $\delta_0, \delta_1 : \one \rightarrow$ sending $\pt$ to 0 and 1 respectively.
Also, we define $\delta : \one + \one \rightarrow I^1$ by $\delta_0 + \delta_1$.

Next we define the homotopy pushout.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\hpushout$ $(A, B, C : \Type)$ $(f : A \rightarrow B)$ $(g : A \rightarrow C)$ :=
| $\inl$ : $B \rightarrow$ $\hpushout$ $A$ $B$ $C$ $f$ $g$
| $\inr$ : $C \rightarrow$ $\hpushout$ $A$ $B$ $C$ $f$ $g$
| $\glue$ : $\prod (a : A), \inl (f \> a) = \inr (g \> a)$
\end{lstlisting}
Note the similarities with the construction of the pushout.
Also, we can define the homotopy colimit as a higher inductive type in much the same way.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\hocolim$ $(F : \mathbb{N} \rightarrow \Type)$ $(f : \prod (n : \mathbb{N}, F \> n \rightarrow F(n+1)))$ :=
| $\inc$ : $\prod (n : \mathbb{N}), F \> n \rightarrow$ $\hocolim$ $F$ $f$
| $\com$ : $\prod (n : \mathbb{N}) (x : F \> n), \inc \> n \> x = \inc \> (n+1) \> (f \> n \> x)$
\end{lstlisting}

\section{The Approximator}
\label{sec:approximator}
Let us assume that some higher inductive type $H$ is given.
In order to construct $H$ as a colimit, we first need to give the approximations in the colimit, and for that we define the \emph{approximator}.

Before giving the definition, let us think about how it should be given.
By Ad\'amek's theorem, every inductive type can be given as a colimit.
An inductive type $T$ is given by a polynomial functor $F$ and a constructor $c : F \> T \rightarrow T$, and then $T$ is the colimit of the sequence
\[
\xymatrix
{
	\zero \ar[r] & F \> \zero  \ar[r] & F(F \> \zero) \ar[r] & \ldots
}
\]
To understand what this does, let us assume that $F \> X = X + 1$, so that $T = \mathbb{N}$.
This means we have two inclusions  $\xymatrix{1 \ar[r] & 1+X}$ and  $\xymatrix{X \ar[r] & 1+X}$, and we call them $0_C$ and $S_C$ respectively.
At every step we formally add for each $x : X$ a successor $S_C \> x$, and we add $0_C$.
Repeatedly applying this construction to the empty type $\zero$ gives the natural numbers $\mathbb{N}$.

For higher inductive types one would like to do a similar construction.
The first difference is that instead of starting with nothing and adding each constructor at every step, we start with the nonrecursive constructors, and add recursive constructors at every step.
Also, since extra equalities might be present in the higher inductive type, we need to make identifications during the construction.
Rather than just adding points at every step, we also need to glue the right paths.

To understand what should be done more precisely, let us consider an example.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\mathbb{N}_2$ :=
| $0$ : $\mathbb{N}_2$
| $S$ : $\mathbb{N}_2 \rightarrow \mathbb{N}_2$
| $p$ : $S(S \> 0) = 0$
\end{lstlisting}
The first approximation just has a constructor $0$, and after that we add a constructor for $S \> 0$ to obtain the second approximation.
In the third approximation, which we call $F \> 3$, we found inhabitants $0$, $S \> 0$, and $S(S \> 0)$, and now we can make the first identification.
To do so, we take the following homotopy pushout
\[
\xymatrix
{
	\one + \one \ar[d]_{0 + S(S \> 0)} \ar[r]^-{\delta} & I^1 \ar[d]\\
	F \> 3\ar[r] & P \> 3
}
\]
to obtain the actual third approximation $P \> 3$, and we continue our construction with that one.
Note that to glue during the $n$th step, we need refer to elements from the $(n-2)$th step.
So, in order to do the identification of the $n$th step, one needs to refer back to a previous approximation.

Note that one always has to go back a fixed number of steps due to the usage of constructor terms.
By extending the syntax, one can also think of examples where one needs to go back an arbitrary amount of steps.
For that, we consider the following example.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\mathbb{N}_2$ :=
| $0$ : $\mathbb{N}_2$
| $S$ : $\mathbb{N}_2 \rightarrow \mathbb{N}_2$
| $p$ : $\prod (n : \mathbb{N}), S^n \> 0 = 0$
\end{lstlisting}
This example might seem like it is allowed in the syntax, but it is not.
The term $S^n$ is defined as a polymorphic function which needs the type as argument, and that is not allowed with constructor terms.
In this extension the construction will be more complicated, and the construction is not predicative, so this will not be considered in this paper.

Let us make this idea formal, and for that we start with a higher inductive type which is given as follows.
\lstset{language=Coq}
\begin{lstlisting}[label={lst:HIT}]
Inductive $H$ :=
| $c_{\nonrec}$ : $A_{\nonrec} \rightarrow H$
| $c_{\rec}$ : $A_{\rec} \> H \rightarrow H$
| $p_i$ : $\prod (x : B_i \> H), t_i = r_i$ $\quad (i = 1, \ldots, m)$
\end{lstlisting}
Note that the nonrecursive and recursive point constructors are separated in this definition.
The first approximation will be given using the nonrecursive constructors.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H_{\nonrec}$ :=
| $c_{\nonrec}'$ : $A_{\nonrec} \rightarrow H_{\nonrec}$
\end{lstlisting}

Next we need to generate the other approximations, and that will be done in two steps.
First, we note that types can be extended with a recursive constructor.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H_{\rec}$ $(P : \Type)$:=
| $c_{\rec}'$ : $A_{\rec} \> P \rightarrow H_{\rec} \> P$
\end{lstlisting}
To do the identifications, we need to be able to interpret the constructor terms.
For that we use that each constructor terms only uses each constructor  a finite amount of times, and thus there is a maximum number $n \geq 1$ of times a constructor is used.
In order to define the approximator, we start with a type $H_{\Con}^n$ in which all the constructor terms can be interpreted.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H_{\Con}^n$ $(P : \Type)$:=
| $\term$ : $P + H_{\rec} \> P + \ldots + H_{\rec}^n \> P \rightarrow H_{\Con} \> P$
\end{lstlisting}

If $n$ is clear from the context, then we shall not write it down.

\begin{lemma}
Suppose, we have a constructor term $t$ such that $x : F \> T \Vdash t : G \>T$ which uses at most $n$ constructors, and that we have a map $c_{\nonrec}' : A_{\nonrec} \rightarrow P$.
Then $t$ induces a map $\overline{t} : F \> P \rightarrow G \> H_{\Con}^n$ by replacing the constructors $c_{\nonrec}$ and $c_{\rec}$ by $c_{\nonrec}'$ and $c_{\rec}'$ respectively.
\end{lemma}

\begin{proof}
We use induction on the form of the constructor term.
\begin{itemize}
	\item $t = a$ with $a : B$ and $B$ does not use $T$. Then we define $\overline{t} \> y = a$.
	\item $t = x$ with $x : F \> T$. Then we define $\overline{t} \> y = \inn_P y$.
	\item $t = c_{\nonrec} a$ with $a : A_{\nonrec}$. Then we define $\overline{t} \> y = c_{\nonrec}' a$.
	\item $t = c_{\rec} r$ with $r : A_{\rec} \> T$ where $r$ uses at most $n-1$ constructors. 
			  By induction we have a map $\overline{r} : F \> P \rightarrow A_{\rec} \> H_{\Con}^{n-1}$.
			  Then we define $\overline{t} \> y = c_{\rec}' (\overline{r} \> x)$.
	\item For the rules for the projection, pairing and injection it is trivial. \qedhere
\end{itemize}
\end{proof}

\begin{definition}
Let a higher inductive type $H$ be given as before, and let the type $H_{\Con}$ be defined as before.
Then we define the \emph{approximator} $H_{\Approx}$, which has a parameter $P$, of $H$ the following pushout
\[
\xymatrix
{
	\sum_{i = 1}^m ((\one + \one) \times B_i \> P) \ar[d]_{t_i + r_i} \ar[r]^-\delta & \sum_{i = 1}^m (I^1 \times B_i \> P) \ar[d]\\
	H_{\Con} \> P \ar[r]_{q_1} & H_{\Approx} \> P
}
\]
Note that this can be written as the homotopy pushout.
\end{definition}

\begin{definition}
In the setting as described, we can define a sequence of approximations to $H$ as follows
\begin{align*}
F \> 0 &= H_{\nonrec},\\
F(n+1) &= H_{\Approx}(F \> n) \qedhere
\end{align*}
\end{definition}

For the colimit we also need maps $f \> n : F \> n \rightarrow F(n + 1)$.
Note that we always have the following sequence of maps
\[
\xymatrix@1
{
	P \ar[r] & H_{\Con} \> P \ar[r] & H_{\Approx} P.
}
\]
Taking $P$ to be $F \> n$, then we have $F (n+1) = H_{\Approx} (F \> n)$, and thus the composition gives the map $F \> n \rightarrow F(n + 1)$.

\section{The Rules}
\label{sec:rules}
Now we have a candidate for the higher inductive type, namely $\hocolim \> F \> f$.
In this section we shall prove that we can define the introduction rules, the eliminator, and show the computation rules.
We will do this step by step, and refer to lemmata in Section \ref{sec:Lemmata}.

\subsection{Introduction Rules}
In order to show that this is the desired type, we first show that it has the correct introduction rules.
These come in three flavors: the nonrecursive and the recursive points, and the paths.

Let us start by defining a map $A_{\nonrec} \rightarrow \hocolim \> F \> f$ which gives the introduction rule for the nonrecursive point constructors.
Since $F \> 0$ is defined by $H_{\nonrec}$, which has a constructor $c'_{\nonrec} : A_{\nonrec} \rightarrow H_{\nonrec}$, this can be defined by the following composition.
\[
\xymatrix
{
	A_{\nonrec} \ar[rr]^-{c'_{\nonrec}}
		& & F \> 0 \ar[rr]^-{\inc}
		& & \hocolim \> F \> f
}
\]

Next we show that we also have the recursive constructor meaning that we have a map $A_{\rec} \> (\hocolim \> F \> f) \rightarrow \hocolim \> F \> f$.
This is slightly more complicated, and for that we first need a lemma which says that colimits over $\mathbb{N}$ commute with polynomials.

\begin{lemma}
\label{lem:colim_commute_poly}
The types $A \> (\hocolim \> F \> f)$ and $\hocolim \> (A \circ F) \> (A \> f)$ are isomorphic for all polynomials $A$.
\end{lemma}

\begin{proof}

\end{proof}

Now we will construct the map $A_{\rec} \> (\hocolim \> F \> f) \rightarrow \hocolim \> F \> f$, and by Lemma \ref{lem:colim_commute_poly} it suffices to make a map $\hocolim \> (A_{\rec} \circ F) \> (A \> f) \rightarrow \hocolim \> F \> f$.
For this we use the recursion rule of $\hocolim$, and we start with the following string of maps
\[
\xymatrix
{
		A_{\rec}(F \> n) \ar[r]^-{c_{\rec}'} 
		& H_{\rec}(F \> n) \ar[rr]^{\term \circ \iota_1} &
		& H_{\Con}(F \> n) \ar[r]^-{q_1}
		& H_{\Approx}(F \> n) = F(n + 1)
}
\]
where the map $H_{\rec}(F \> n) \rightarrow H_{\Con}(F \> n)$ is the inclusion and the map $H_{\Con}(F \> n) \rightarrow H_{\Approx}(F \> n)$ is the pushout map.
Composing this map with $\inc$, gives maps $A_{\rec}(F \> n) \rightarrow \hocolim \> F \> f$ for all $n : \mathbb{N}$.

Next we need to show the commutativity of the following triangle.
\[
\xymatrix
{
	A_{\rec}(F \> n) \ar[rr]^{A \> f \> n} \ar[dr] & & A_{\rec}(F(n+1)) \ar[dl] \\
	& \hocolim \> F \> f &
}
\]
Let us start with the following rectangle
\[
\xymatrix
{
	A_{\rec}(F \> n) \ar[r]^-{c_{\rec}'} \ar[d]_{A \> f \> n} 
		& H_{\rec}(F \> n) \ar[rr]^{\term \circ \iota_1} \ar[d]_{H_{\rec} \> f \> n} &
		& H_{\Con}(F \> n) \ar[d]_{H_{\Con} \> f \> n}\\
	A_{\rec}(F(n+1)) \ar[r]_-{c_{\rec}'} 
		& H_{\rec}(F(n+1)) \ar[rr]_{\term \circ \iota_1} &
		& H_{\Con}(F(n+1))
}
\]
The left square commutes, because by definition of $H_{\rec} \> f$ we have
\[
H_{\rec} \> f \> n \> (c_{\rec}' x) = c_{\rec}' (A_{\rec} \> f \> n \> x).
\]
For a similar reason the right triangle commutes as well.
Hence, it suffices to show that the following diagram commutes.
\[
\xymatrix
{
	H_{\Con}(F \> n) \ar[d]_{H_{\Con} \> f \> n} \ar[r]^-{q_1}
		& H_{\Approx}(F \> n) \ar[d]^{f \> n}\\
	H_{\Con}(F(n+1)) \ar[r]_-{q_1}
		& H_{\Approx}(F(n+1))
}
\]
By expanding the definitions, we see that $H_{\Approx}(F \> n) \rightarrow H_{\Approx}(F(n+1))$ is defined by $p_1 \circ \term \circ \iota_1$.
This means that it suffices to show that the upper triangle in the following square commutes.
\[
\xymatrix
{
	H_{\Con}(F \> n) \ar[d]_{H_{\Con} \> f \> n} \ar[r]^{p_1}
	& H_{\Approx}(F \> n) \ar[d]^{f \> n} \ar[dl]|{\term \circ \iota_0}\\
	H_{\Con}(F(n+1)) \ar[r]_{p_1}
	& H_{\Approx}(F(n+1))
}
\]
The upper triangle commutes by definition.
All in all, we get the desired map
\[
\xymatrix
{
	A \> (\hocolim \> F \> f) \ar[r] & \hocolim \> (A \circ F) \> (A \> f) \ar[r] & \hocolim \> F \> f
}
\]

Next we need to define the introduction rules for the paths.
For this we first need to observe that a type $X$ has the paths $p_i : \prod (x : B_i \> X), t_i = r_i$ iff the following diagram is a pushout
\[
\xymatrix
{
	\sum_{i = 1}^m \two \times (B_i \> X) \ar[r] \ar[d]_{t_i + r_i} & \sum_{i = 1}^m B_i \> X \times I^1 \ar[d]\\
	X \ar[r] & X
}
\]
We shall use this observation to show that $\hocolim \> F \> f$ has the right paths.
Taking $X$ to be $\hocolim \> F \> f$, we thus need to show the following diagram is a pushout.
\[
\xymatrix
{
	\sum_{i = 1}^m \two \times (B_i \> (\hocolim \> F \> f)) \ar[r] \ar[d] & \sum_{i = 1}^m I^1 \times (B_i \> (\hocolim \> F \> f)) \ar[d]\\
	\hocolim \> F \> f \ar[r] & \hocolim \> F \> f
}
\]
Note that homotopy colimits commute with products, so we can rewrite it to where the summations are implicit.
\[
\xymatrix
{
	\hocolim \> ((2 \times B_i) \circ F) \> ((2 \times B_i) \> f) \ar[r] \ar[d] & \hocolim \> ((B_i \times I) \circ F) \> ((B_i \times I) \> f) \ar[d]\\
	\hocolim \> F \> f \ar[r] & \hocolim \> F \> f
}
\]
Since homotopy colimits commute with pushouts, it suffices to show that
\[
\xymatrix
{
	\sum_{i=1}^m 2 \times (B_i \> (F \> n)) \ar[r] \ar[d] & \sum_{i=1}^k I^1 \times B_i (F \> n) \ar[d]\\
	F(n+1) \ar[r] & F(n+1)
}
\]
This holds by definition of $F(n+1)$.

\subsection{Elimination Rule}
The next step will be to show that $\hocolim \> F \> f$ has the right eliminator.


\subsection{Computation Rules}

\section{Lemmata}
\label{sec:Lemmata}

\begin{lemma}
Colimits commute with coproducts.
\end{lemma}

\begin{lemma}
Colimits commute with products.
\end{lemma}

\begin{lemma}
Colimits commute with pullbacks.
\end{lemma}

\section{Conclusion and Further Work}



\nocite{*}

%%
%% Bibliography
%%

%% Either use bibtex (recommended), 

\bibliography{lipics-v2016-sample-article}

%% .. or use the thebibliography environment explicitely



\end{document}
