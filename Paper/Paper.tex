\documentclass[a4paper,UKenglish]{lipics-v2016}
%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
% for section-numbered lemmas etc., use "numberwithinsect"

\usepackage{microtype}%if unwanted, comment out or use option "draft"

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the recommended bibstyle

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{The Three-HITs Theorem}
\titlerunning{The Three-HITs Theorem} %optional, in case that the title is too long; the running title should fit into the top page column

%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
\author[1]{Andrej Bauer\thanks{
The author acknowledges the financial support from the Slovenian Research Agency (research core funding No.~P1-0294) at Institute of Mathematics, Physics and Mechanics, Ljubljana, Slovenia. This material is based upon work supported by the Air Force Office of Scientific Research, Air Force Materiel Command, USAF under Award No.~FA9550-14-1-0096.}}
\author[2]{Niels van der Weide\thanks{This work was partially supported by EU COST Action Eutypes (CA15123).}}
\affil[1]{University of Ljubljana, Slovenia\\
  \texttt{Andrej.Bauer@andrej.com}}
\affil[2]{Department of Computer Science, Radboud University, Nijmegen, The Netherlands\\
  \texttt{nweide@cs.ru.nl}}
\authorrunning{A.\ Bauer and N.\ van der Weide} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'

\Copyright{Andrej Bauer and Niels van der Weide}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\subjclass{F.4.1 Mathematical Logic}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation". 
\keywords{homotopy type theory, higher inductive types, category theory}% mandatory: Please provide 1-5 keywords
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\usepackage[all,cmtip]{xy}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{thmtools}



\declaretheorem[style=definition,qed=$\blacksquare$]{construction}


\input{coq.sty}
\input{bussproofs.sty}

% In order to avoid macro pollution, we should comment each macro
% so that we know what it is about

\newcommand{\tyFont}[1]{\textsf{#1}} % the font used to display types
\newcommand{\termFont}[1]{\textsf{#1}} % the font used to term constants
\newcommand{\nat}{\tyFont{N}} % the type of natural numbers
\newcommand{\lift}[1]{\overline{#1}} % the lifting of a type family by a polynomial
\newcommand{\defeq}{\mathrel{{:}{\equiv}}} % definitional equality
\newcommand{\idmap}[1]{\termFont{id}_{#1}} % identity map
\newcommand{\inl}[1]{\termFont{inl}\,#1} % left inclusion into a sum
\newcommand{\inr}[1]{\termFont{inr}\,#1} % right inclusion into a sum

\newcommand{\dprod}[1]{{\textstyle\prod_{#1}}\,} % dependent product
\newcommand{\dsum}[1]{{\textstyle\sum_{#1}}\,} % dependent sum

% Below are macros which have not been documented and are possibly
% unused (probably not)

\newcommand{\Boperator}[1]{\mathsf{#1}}
\newcommand{\comment}[1]{-- #1 --}
\newcommand{\remove}[1]{}
\newcommand{\inn}{\Boperator{in}}

\newcommand{\fpath}[0]{\> \Box \>}
\newcommand{\conc}[0]{\bullet}
\newcommand{\comp}[0]{\circ \,}

\newcommand{\zero}[0]{\textbf{0}}
\newcommand{\one}[0]{\textbf{1}}
\newcommand{\two}[0]{\textbf{2}}


\newcommand{\frec}[0]{\!\operatorname{rec}}
\newcommand{\ind}[0]{\!\operatorname{ind}}
\newcommand{\rec}[0]{\operatorname{rec}}
\newcommand{\nonrec}[0]{\operatorname{nonrec}}

\newcommand{\ap}[0]{\operatorname{ap}}
\newcommand{\apd}[0]{\operatorname{apD}}

\newcommand{\term}[0]{\textbf{term}}
\newcommand{\Con}[0]{\textbf{Con}}
\newcommand{\Approx}[0]{\textbf{Approx}}

\newcommand{\refl}[0]{\Boperator{refl}}

\newcommand{\FE}[0]{\Boperator{FE}}
\newcommand{\funext}[0]{\Boperator{FunExt}}
\newcommand{\coeq}[0]{\Boperator{coeq}}
\newcommand{\inC}[0]{\Boperator{inC}}
\newcommand{\glueC}[0]{\Boperator{glueC}}

\newcommand{\pcoeq}[0]{\Boperator{pcoeq}}
\newcommand{\inP}[0]{\Boperator{inP}}
\newcommand{\glueP}[0]{\Boperator{glueP}}

\newcommand{\hpushout}[0]{\Boperator{hpushout}}
\newcommand{\hocolim}[0]{\Boperator{hocolim}}
\newcommand{\seg}[0]{\Boperator{seg}}
\newcommand{\glue}[0]{\Boperator{glue}}
\newcommand{\inc}[0]{\Boperator{inc}}
\newcommand{\com}[0]{\Boperator{com}}
\newcommand{\Type}[0]{\operatorname{\textsc{Type}}}
\newcommand{\pt}[0]{*}

\newcommand{\dak}[1]{\widehat{#1}}
\newcommand{\hatt}{\dak{t}}
\newcommand{\hatr}{\dak{r}}


\begin{document}

\maketitle

\begin{abstract}
We show that all higher inductive types can be constructed from coequalizers, path coequalizers and homotopy colimits.
The proof is inspired by Ad\'amek's theorem which constructs inductive types as a colimit of a functor.
This way one can reason about all higher inductive types by instead studying a small number of examples.
 \end{abstract}

\section{Introduction}
Higher inductive types (HITs) generalize normal inductive types by allowing constructors for both points and paths, rather than just for the points.
While an inductive type is freely generated from a signature, a higher inductive type is freely generated from a signature together with constructors for equations.
Numerous examples and definitions of such types have already been given in the literature \cite{altenkirch2016quotient,awodey2012inductive,basoldhigher,sojakova2015higher,hottbook}, but a definition with a good metatheory is still lacking.
As a step towards that goal, we simplify the definition given in \cite{basoldhigher} bringing it closer to the intuition and the intended meaning.

Philosophically, one sees an inductive type as a type `which is built step by step'.
Starting with the nonrecursive constructors, new terms are made by applying recursive constructors to previously built terms.
This is explained by the fact that inductive types are initial algebras for a functor \cite{dybjer1994inductive,dybjer2003induction} and that such algebras are obtained by fixed point iteration \cite{adamek1974free}.
Following our intuition on higher inductive types, one would expect that they can be constructed in a similar fashion.
However, since equations are also allowed in the specification, identifications need to be made during the construction.

The goal of this paper is to formally justify this idea by showing that the higher inductive types defined in \cite{basoldhigher} can be generated from three specific higher inductive types, namely coequalizers, path coequalizers, and homotopy colimit.
More concretely, we will prove the following theorem.
\begin{theorem}[Three-HITs Theorem]
\label{thm:three-hit}
In Martin-L\"of type theory extended with a coequalizers, path coequalizers and homotopy colimits, we can interpret each higher inductive type from \cite{basoldhigher}. 
This means that for each HIT we can define a type with the same introduction, elimination and computation rules.
\end{theorem}
Also, this generalizes the results in \cite{doorn2016constructing,kraus2014general,kraus2016constructions} where the result is showed for truncations.
With this result the metatheory of higher inductive types could be simplified significantly, because rather than a general class, one only needs to check metatheoretical properties for three HITs.

In Section \ref{sec:prelims} we shall recall some of the required material for this paper.
More concretely, we give the syntax of higher inductive types, and using that we define required types.
Next we define the approximating sequence of a higher inductive type in Section \ref{sec:approximator}, and in Section \ref{sec:rules} we show that the colimit of this sequence satisfies the rules of the given HIT.
For this we need some lemmata which are proved in Section \ref{sec:Lemmata}.
These are formalized in \textsc{Coq} \cite{CoqImpl} using the library from \cite{bauer2016hott}.

\section{A definition of HITs}
\label{sec:prelims}

In this section we provide the definitions of higher inductive types that we shall
consider. We recall the scheme for specifying higher inductive types
from~\cite{basoldhigher}.

\begin{definition}
  A \emph{polynomial (expression)} in a type variable $X$ is a built inductively from the
  variable $X$, type constants~$C$, binary products $\times$, and binary sums $+$.
\end{definition}

For example, if $\nat$ is the type of natural numbers, the expression
$(X + \nat) \times X$ is a polynomial expression in~$X$. We write $P[X]$ to indicate a
polynomial in variable $X$. Given a type $A$, we may substutute $A$ for $X$ to obtain a
type $P[A]$, as follows:
%
\begin{align*}
  X[A] &\defeq A, &
  (P_1 \times P_2)[A] &\defeq P_1[A] \times P_2[A], \\
  C[A] &\defeq C, &
  (P_1 + P_2)[A] &\defeq P_1[A] + P_2[A].
\end{align*}
%
In a similar fashion a map $f \> A \to B$ is transformed to a map $P[f] : P[A] \to P[B]$:
%
\begin{align*}
  X[f] &\defeq f, &
  (P_1 \times P_2)[f] \, (x,y) &\defeq (P_1[f]\, x, P_2[f] \, y), \\
  C[f] &\defeq \idmap{C}, &
  (P_1 + P_2)[f](\inl{x}) &\defeq \inl{(P_1[f]\,x)}, \\
  & &
  (P_1 + P_2)[f](\inr{y}) &\defeq \inr{(P_2[f]\,y)}.
\end{align*}
%
Somewhat less obviously, a polynomial acts on a type family $B : A \to \Type$ to
give its lifting $\lift{P}[B] : P[A] \to \Type$,
%
\begin{align*}
  \lift{X}[B] \, u &\defeq B\,u, &
  \lift{P_1 \times P_2}[B] \, u \defeq (\lift{P_1}[B]\,u) \times (\lift{P_2}[B]\,u), \\
  \lift{C}[B] \, u &\defeq C, &
  \lift{P_1 + P_2}[B] \, (\inl{u})\defeq \lift{P_1}[B]\,u, \\
  & &
  \lift{P_1 + P_2}[B] \, (\inr{u})\defeq \lift{P_2}[B]\,u,
\end{align*}
%
while a map $f \> \dprod{x \> A} B_1\,x \to B_2\,x$ lifts to
$\lift{P}[f] \> \dprod{u : P[A]} \lift{P}[B_1]\,u \to \lift{P}[B_2]\,u$:
%
\begin{align*}
  \lift{X}[f] \, u &\defeq f \, u &
  \lift{P_1 \times P_2}[f] \, (u_1, u_2) &\defeq (\lift{P_1}[f]\,u_1, \lift{P_2}[f]\,u_2) \\
  \lift{C}[f] \, u &\defeq u &
  \lift{P_1 + P_2}[f] \, (\inl{u})\defeq \lift{P_1}[f]\,u, \\
  & &
  \lift{P_1 + P_2}[f] \, (\inr{u})\defeq \lift{P_2}[f]\,u.
\end{align*}
%
There is of course a strong analogy between the action of $P[X]$ and a polynomial functor,
but we hesitate to call $P[X]$ a functor as there is no category to speak of, and in any
case the manipulations we have just described are syntactic.

Next we define the notion of a constructor term.
\begin{definition}
\label{def:constructor-term}
Given is a function $c : A \> T \rightarrow T$ with $A$ polynomial and $T$ a type.
Then we say $t$ is a \emph{constructor term} over $c$ if we can find polynomials $F$ and $G$ such that $x : F \> T \vdash t : G \> T$ can be derived using the following rules.
\begin{gather*}
        \AxiomC{$t : B$}
        \AxiomC{$T$ does not occur in $B$}
        \BinaryInfC{$x:F \> T \vdash t : B$}
        \bottomAlignProof
        \DisplayProof 
         \quad
        \AxiomC{}
        \UnaryInfC{$x : F \> T \vdash x : F \> T$}
        \bottomAlignProof
        \DisplayProof
        \quad
        \AxiomC{$x : F \> T \vdash r : A \> T$}
        \UnaryInfC{$x : F \> T \vdash c \> r : T$}
        \bottomAlignProof
        \DisplayProof
        \\[7pt]
        \AxiomC{$j \in \{1, 2\}$}
        \AxiomC{$x : F \> T \vdash r : G_1 \> T \times G_2 \> T$}
        \BinaryInfC{$x : F \> T \vdash\pi_j \> r : G_j \> T$}
        \bottomAlignProof
        \DisplayProof
        \quad
        \AxiomC{$j \in \{1, 2\}$}
        \AxiomC{$x : F \> T \vdash r_j : G_j$}
        \BinaryInfC{$x : F \> T \vdash (r_1, r_2) : G_1 \> T\times G_2 \> T$}
        \bottomAlignProof
        \DisplayProof
        \\[7pt]
        \AxiomC{$j \in \{1, 2\}$}
        \AxiomC{$x : F \> T \vdash r : G_j \> T$}
        \BinaryInfC{$x : F \> T : \inn_j \> r : G_1 \> T + G_2 \> T$}
        \bottomAlignProof
        \DisplayProof
\end{gather*}
\end{definition}

Using constructor terms we give the following scheme of higher inductive types.
\begin{definition}
\label{def:hit}
A \emph{higher inductive type} is defined according to the following scheme
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H$ :=
| $c$ : $A \> H \rightarrow H$
| $p_i$ : $\prod (x : B_i \> H), t_i = r_i$ $\quad (i = 1, \ldots, m)$
\end{lstlisting}
where $A$ and each $B_i$ are polynomials, and each $t_i$ and $r_i$ are constructor terms over $c$ of type $H$ with $x : B_i \> H$ as variable.
\end{definition}

Before we can give the rules for higher inductive types, we need to define the lift of a constructor term.
\begin{definition}
Given is a constructor $c : A \> H \rightarrow H$, a type family $Y : H \rightarrow \Type$, and a term $f : \prod (x: A \> H), \bar{A} \> Y \> x \rightarrow  Y(c \> x)$.
For a constructor term $F \> H \vdash r : G \> H$ we define the \emph{lift $\dak{r}$ of $r$} with type 
$
x : F \> H, h_x : \bar{F} \> Y \> x \vdash \dak{r} : \bar{G} \> Y \> r
$
by induction in $r$ as follows.
        \begin{align*}
                \dak{t} & := t
                & \dak{x} & := h_x &
                \dak{c_i \> r} & := f_i \> r \> \dak{r}\\
                \dak{\pi_j \> r} & := \pi_j \> \dak{r} &
                \dak{(r_1, r_2)} & := (\dak{r_1}, \dak{r_2})
                & \dak{\inn_j \> r} & := \dak{r}
        \end{align*}
\end{definition}

With all these notions we can give the introduction, elimination and computation rules of higher inductive types.
The introduction rules for $H$ as given in Definition \ref{def:hit} are
\[
c : A \> H \rightarrow H,
\]
\[
p_i : \prod (x : B_i \> H), t_i = r_i.
\]
We also have an elimination rule for which we use the lifting of constructor terms.
\begin{equation*}
        \AxiomC{$\vdash Y : H \rightarrow \Type$}
        \noLine
        \UnaryInfC{$\vdash f : \prod (x : A \> H), \bar{A} \> Y \> x \rightarrow Y \> (c \> x)$}
%       \noLine
        \AxiomC{$\vdash q_i : \prod (x : B_i \> H) (h_x : \bar{B}_i \> Y \> x), \hatt_i =_{p_j \, x} \hatr_j$}
        \BinaryInfC{$\vdash H\frec(f, q_1, \ldots, q_n) : \prod (x : H), Y \> x$}
        \DisplayProof
\end{equation*}
Let us abbreviate $H\frec(f, q_1, \ldots, q_n)$ by $H\frec$.
The type $H$ also has computation rules for each point $t : A \> H$
\begin{equation*}
H\frec \> (c \> t) \equiv f \> t \> (\bar{A} \> H\frec \> t),
\end{equation*}
and for each $a : B_i \> H$
\begin{equation*}
\apd \> H\frec \> (p_i \> a) \equiv q_i \> a \> (\bar{B}_i \> H\frec \> a).
\end{equation*}
Note that these equalities are definitional rather than propositional.

Let us now give some examples of higher inductive types which will be crucial in this paper.
The first one identifies points in some type, and we call it the \emph{coequalizer}.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\coeq$ $(A, B : \Type)$ $(f, g : A \rightarrow B)$ :=
| $\inC$ : $B \rightarrow \coeq \> A \> B \> f \> g$
| $\glueC$ : $\prod (a : A), \inC \> (f \> a) = \inC \> (g \> a)$
\end{lstlisting}
The elimination rule for this type is as follows
\begin{equation*}
        \AxiomC{$\vdash Y : \coeq \> A \> B \> f \> g \rightarrow \Type$}
        \noLine
        \UnaryInfC{$\vdash i_Y : \prod (b : B), Y \> (\inC \> b)$}
        %       \noLine
        \AxiomC{$\vdash g_Y : \prod (a : A), \glueC_*(i_Y \> (f \> a)) = i_Y \> (g \> a)$}
        \BinaryInfC{$\vdash \coeq\frec(i_Y, g_Y) : \prod (x : \coeq \> A \> B \> f \> g), Y \> x$}
        \DisplayProof
\end{equation*}
Note the similarities with the definition of the coequalizer in category theory \cite{mac2013categories}.

Next we define a type which identifies two paths in some type which we shall call the \emph{path coequalizer}.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\pcoeq$ $(A, B : \Type)$ $(p : A \rightarrow \sum (b_1, b_2 : B), (b_1 = b_2) \times (b_1 = b_2))$ :=
| $\inP$ : $B \rightarrow \pcoeq \> A \> B \> f \> g$
| $\glueP$ : $\prod (a : A), \ap \> \inC \> (\pi_1(\pi_3(p \> a))) = \ap \> \inC \> (\pi_2(\pi_3(p \> a)))$
\end{lstlisting}
We will abbreviate $p_i \> a = \pi_i(\pi_3(p \> a))$ for $i = 1, 2$.
Note that this type has 2-paths, so it does not follow the given syntax.
Furthermore, the identified paths used in the parameter are obliged to have the same endpoints.
The introduction and computation rules are as expected, but we will give the elimination rule.
\begin{equation*}
        \AxiomC{$\vdash Y : \pcoeq \> A \> B \> f \> g \rightarrow \Type$}
        \noLine
        \UnaryInfC{$\vdash i_Y : \prod (b : B), Y \> (\inP \> b)$}
        %       \noLine
        \AxiomC{$\vdash g_Y : \prod (a : A), \apd \> i_Y \> (p_1 \> a) = \apd \> i_Y \> (p_2 \> a)$}
        \BinaryInfC{$\vdash \pcoeq\frec(i_Y, g_Y) : \prod (x : \pcoeq \> A \> B \> f \> g), Y \> x$}
        \DisplayProof
\end{equation*}

The last HIT we need is the homotopy colimit, and for that we again are inspired by the definition from category theory.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\hocolim$ $(F : \mathbb{N} \rightarrow \Type)$ $(f : \prod (n : \mathbb{N}, F \> n \rightarrow F(n+1)))$ :=
| $\inc$ : $\prod (n : \mathbb{N}), F \> n \rightarrow$ $\hocolim$ $F$ $f$
| $\com$ : $\prod (n : \mathbb{N}) (x : F \> n), \inc \> n \> x = \inc \> (n+1) \> (f \> n \> x)$
\end{lstlisting}
Now the elimination rule is as follows.
\begin{equation*}
        \AxiomC{$\vdash Y : \hocolim \> F \> f \rightarrow \Type$}
        \noLine
        \UnaryInfC{$\vdash i_Y : \prod (n : \mathbb{N}) (x : F \> n), Y \> (\inc \> n \> x)$}
        \noLine
        \UnaryInfC{$\vdash c_Y : \prod (n : \mathbb{N}) (x : F \> n), \com_*(i_Y \> n \> x) = i_Y \> (n+1) \> (f \> n \> x)$}
        \UnaryInfC{$\vdash \hocolim\frec(i_Y, c_Y) : \prod (x : \hocolim \> F \> f), Y \> x$}
        \DisplayProof
\end{equation*}

Lastly, we need function extensionality for the proof.
Let us first introduce some notation.

\begin{definition}
Let $A, B$ be types, let $f, g : A \rightarrow B$ be maps, and let $x : A$ be a point of $A$.
Then for all $e : f = g$ we define a path $e \fpath x : f \> x = g \> x$ using path induction which sends $\refl$ to $\refl$.
\end{definition}

\begin{definition}
Given are types $A, B$ and two maps $f, g : A \rightarrow B$.
Then we define the type $\funext$, of which the inhabitants represent proofs of function extensionality, as follows
\[
\funext = (\prod (x : A), f \> x = g \> x) \rightarrow f = g.
\]
\end{definition}

We will assume that we have an inhabitant $\FE : \funext$ such that for $p : \prod (x : A), f \> x = g \> x$ and $x : A$ we have
\[
(\FE \> p) \fpath x = p \> x.
\]
In homotopy type theory function extensionality can be proved by assuming univalence \cite{UnivalenceFE} or by assuming the existence of an interval object \cite{IntervalFE}.

\section{The Approximator}
\label{sec:approximator}
Let us assume that some higher inductive type $H$ is given.
In order to construct $H$ as a colimit, we first need to give the approximations in the colimit, and for that we define the \emph{approximator}.

Before giving the definition, let us acquire inspiration by looking in more detail at how an inductive type is constructed.
Such a type $T$ is defined by a constructor $c : A \> T \rightarrow T$ with $A$ polynomial.
Equivalently, we can define the type $T$ with a signature which is a polynomial functor $A$, and then by Ad\'amek's theorem $T$ is the following colimit.
\[
\xymatrix
{
        \zero \ar[r] & A \> \zero  \ar[r] & A(A \> \zero) \ar[r] & \ldots
}
\]
To understand what this does, let us assume that $A \> X = 1 + X$, so that $T = \mathbb{N}$.
This means we have two inclusions  $\xymatrix{1 \ar[r] & 1+X}$ and  $\xymatrix{X \ar[r] & 1+X}$, and we call them $0_C$ and $S_C$ respectively.
At every step we formally add for each $x : X$ a successor $S_C \> x$, and we add $0_C$.
Repeatedly applying this construction to the empty type $\zero$ gives the natural numbers $\mathbb{N}$.

One would like to construct higher inductive types in a similar fashion.
The first difference is that instead of starting with $\zero$, we start with all the nonrecursive constructors.
Also, in this construction, the functor $A$ is applied at every step.
Instead we will add terms built from the recursive constructors using previously constructed terms as arguments.
Since extra equalities might be present in the higher inductive type, we need to make identifications during the construction.
Rather than just adding points at every step, we also need to glue the specified paths.

To understand more precisely what should be done, let us consider an example.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $\mathbb{N}_2$ :=
| $0$ : $\mathbb{N}_2$
| $S$ : $\mathbb{N}_2 \rightarrow \mathbb{N}_2$
| $p$ : $S(S \> 0) = 0$
\end{lstlisting}
We build a sequence $F$ of approximations.
The first approximation just has a constructor $0$, and after that we add a constructor for $S \> 0$ to obtain the second approximation.
Continuing this way, we ultimately arrive at the third approximation, which we call $F' \> 3$, where we found inhabitants $0$, $S \> 0$, and $S(S \> 0)$.
Now we can make the first identification, and to do so, we take the following homotopy pushout
\[
\xymatrix
{
        \one + \one \ar[d]_{0 + S(S \> 0)} \ar[r]^-{\delta} & I^1 \ar[d]\\
        F' \> 3\ar[r] & F \> 3
}
\]
to obtain the actual third approximation $F \> 3$, and we continue our construction with that one.
Note that to glue during the $n$th step, we need refer to elements from the $(n-2)$th step.
So, in order to do the identification of the $n$th step, inhabitants from a previous approximation need to be used.

Due to the usage of constructor terms, one always has to go back a fixed number of steps.
By extending the syntax, it might be needed to go back an arbitrary amount of steps.
This happens in the following example.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H$ :=
| $c$ : $H$
| $f$ : $H \rightarrow H$
| $p$ : $\prod (n : \mathbb{N}), f^n \> 0 = 0$
\end{lstlisting}
This example might seem like it is permitted by the syntax, but actually it is not.
The function $f^n$ is defined as a polymorphic map, and using it requires the type $H$ as an argument.
In constructor terms one cannot use the type, and hence this definition is not allowed
An extension with such types will make the construction more complicated, and thus they will not be considered in this paper.

Let us make this idea formal, and for that we start with a higher inductive type given as follows.
\lstset{language=Coq}
\begin{lstlisting}[label={lst:HIT}]
Inductive $H$ :=
| $c$ : $A_{\nonrec} \rightarrow H$
| $c_{\rec}$ : $A_{\rec} \> H \rightarrow H$
| $p_i$ : $\prod (x : B_i \> H), t_i = r_i$ $\quad (i = 1, \ldots, m)$
\end{lstlisting}
Note that the nonrecursive and recursive point constructors are separated in this definition.
The first approximation will be given using the nonrecursive constructors.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H_{\nonrec}$ :=
| $c_{\nonrec}'$ : $A_{\nonrec} \rightarrow H_{\nonrec}$
\end{lstlisting}

Next we need to generate the other approximations, and that will be done in two steps.
First, we note that types can be extended with a recursive constructor.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H_{\rec}$ $(P : \Type)$:=
| $c_{\rec}'$ : $A_{\rec} \> P \rightarrow H_{\rec} \> P$
\end{lstlisting}
To do the identifications, we need to be able to interpret the constructor terms.
For that we use that each constructor terms only uses each constructor  a finite amount of times, and thus there is a maximum number $n \geq 1$ of times a constructor is used.
In order to define the approximator, we start with a type $H_{\Con}^n$ in which all the constructor terms can be interpreted.
\lstset{language=Coq}
\begin{lstlisting}
Inductive $H_{\Con}^n$ $(P : \Type)$:=
| $\term$ : $P + H_{\rec} \> P + \ldots + H_{\rec}^n \> P \rightarrow H_{\Con}^n \> P$
\end{lstlisting}

Note that this type is actually a labeled sum.
This is because $H_{\rec} \> P$ is isomorphic to $A_{\rec} \> P$, and thus this $H_{\Con}^n \> P$ is actually $P + A_{\rec} \> P + \ldots + A_{\rec}^n \> P$.
Hence, we do not need inductive types in general for the construction, but we just need to have sums and products.
If $n$ is clear from the context, then we shall not write it down.
From Lemma \ref{lem:constrTerm} we can conclude that we can interpret the constructor terms in $H_{\Con} \> P$

Now we have sufficient to define the approximator.
Given is the following data
\begin{itemize}
        \item Types $P, Q, R$;
        \item A map $j_Q : H_{\Con} \> Q \rightarrow P$;
        \item An inclusion $j_R : H_{\Con} \> R \rightarrow Q$;
        \item Paths $p_Q : \prod (x : Q), j_Q(\overline{t_i} \> x) = j_Q(\overline{r_i} \> x)$;
        \item Paths $p_R : \prod (x : R), j_R(\overline{t_i} \> x) = j_R(\overline{r_i} \> x)$.
\end{itemize}
The type $H_{\Approx}$ depends on the given data, but for clarity we will suppress it from the notation.
We start with $H_{\Con} \> P$.

First, we need to guarantee that the added paths have the right endpoints.
Note that we have two maps $\overline{t_i}, \overline{r_i} : B_i \> P \rightarrow H_{\Con} \> P$, and that gives the first coequalizer.
\[
\xymatrix
{
        B_i \> P \ar@<-.5ex>[r]_-{\overline{r_i}} \ar@<.5ex>[r]^-{\overline{t_i}} & H_{\Con} \> P \ar[r]^-{\inC_1} & C_1
}
\]

However, this is not exactly the type we want due to coherency issues.
For example, in $P$ we have terms using $c_{\rec}$ at most $k$ times, so in $H_{\Approx} \> P$ we have duplicates of terms using $c_{\rec}$ less than $k$ times.

Remember that we we have $j_Q : H_{\Con} \> Q \rightarrow P$.
Now we define the type $C_2$ which is the coequalizer of the following two arrows.
\[
\xymatrix
{
        H_{\Con} \> Q \ar@<-.5ex>[rrr]_-{H_{\Con} \> (j_Q \circ \inn_1)} \ar@<.5ex>[rrr]^-{\inn_1 \circ j_Q} & & & H_{\Con} \> P \ar[rr]^-{\inC_1} & & C_1
}
\]
To explain what this does, let us assume for a moment that we have one construct $c$ with arity 1.
For $c' \> x$ with $x : Q$, the upper map is the inclusion of $H_{\Con} \> Q$ on the first coordinate of $H_{\Con} \> P$.
The lower map sends $c' \> x$ to $c' \> (j_Q \> (\inn_1 \> x))$, so it replaces $x$ by its image in $P$.

Lastly, we define $H_\Approx$, and for this we make one more identification.
Instead of identifying points, we will identify paths in this step.
Since also paths are added during the construction, there might also be duplicated paths.
The resulting type should be free, so these paths should be identified.
We define a map $q : B_i \> R \rightarrow \sum (x, y : P), (x = y) \times (x = y)$ sending $x : B_i \> R$ to the pair
\[
(\overline{t_i} \> x, \overline{r_i} \> x, \ap \> (j_Q \circ \inn_1) \> (p_R \> x), p_Q \> (B_i \> j_R \> x))
\]
Concluding the construction, we define $H_{\Approx}$ as $\pcoeq \> (B_i \> R) \> C_2 \> q$.

Now we can define the approximating sequence.

\begin{definition}
In the setting as described, we simultaneously define a sequence of approximations $F : \mathbb{N} \rightarrow \Type$ to $H$ and maps $f : \prod(n : \mathbb{N}), F \> n \rightarrow F(n+1)$ as follows.
\begin{itemize}
        \item We define $F \> 0 = H_{\nonrec}$.
        \item We define $F \> 1 = H_{\Approx}$ taking $P = F \> 0$ and $Q, R = \zero$ and the maps are defined by $\zero\frec$.
        \item We define $F \> 2 = H_{\Approx}$ with $P= F \> 1, Q = F \> 0$ and $R =\zero$. We have a map $Q \rightarrow P$ defined to be the composition of all $\inC$ with $\inn_1$.
        \item We define $F(n+3) = H_{\Approx}$ with $P = (F(n+2)$, $Q = F(n+1)$, and $R = F \> n$. The maps $Q \rightarrow P$ and $R \rightarrow Q$ are defined to be the composition of $\inC$ with $\inn_1$ as in the construction. The paths $p_Q$ and $p_R$ are given by the path $\glueC$ from the first coequalizer.
\end{itemize}
For the maps $f \> n : F \> n \rightarrow F(n + 1)$, note that we always have the following sequence of maps
\[
\xymatrix@1
{
        F \> n \ar[r] & H_{\Con} \> (F \> n) \ar[r] & C_1 \ar[r] & \ldots \ar[r] & C_4 \ar[r] & H_{\Approx}.
}
\]
Taking $P$ to be $F \> n$, then we have $F (n+1) = H_{\Approx} (F \> n)$, and thus the composition gives the map $F \> n \rightarrow F(n + 1)$.
\end{definition}

\section{The Rules}
\label{sec:rules}
Now we have defined an object $\hocolim \> F \> f$, which is supposed to interpret the higher inductive type.
In order to finish the proof of Theorem \ref{thm:three-hit}, we need to show that it satisfies the rules.
This means that we have to make functions which interpret the introduction rules, and an eliminator such that the computation rules are satisfied.
We will do this step by step, and refer to lemmata in Section \ref{sec:Lemmata} when needed.

\subsection{Introduction Rules}
In order to show that this is the desired type, we first show that it has the correct introduction rules.
These come in three flavors: the nonrecursive and the recursive points, and the paths.

Let us start by defining a map $A_{\nonrec} \rightarrow \hocolim \> F \> f$ which gives the introduction rule for the nonrecursive point constructor.
Since $F \> 0$ is defined by $H_{\nonrec}$, which has a constructor $c'_{\nonrec} : A_{\nonrec} \rightarrow H_{\nonrec}$, this can be defined by the following composition.
\[
\xymatrix
{
        A_{\nonrec} \ar[rr]^-{c'_{\nonrec}}
                & & F \> 0 \ar[rr]^-{\inc \> 0}
                & & \hocolim \> F \> f
}
\]

Next we show that we also have the recursive point constructor meaning that we have a map $A_{\rec} \> (\hocolim \> F \> f) \rightarrow \hocolim \> F \> f$.
This is slightly more complicated, and for that we first need a lemma which says that colimits over $\mathbb{N}$ commute with polynomials.

\begin{lemma}
\label{lem:colim_commute_poly}
The types $A \> (\hocolim \> F \> f)$ and $\hocolim \> (A \comp F) \> (A \> f)$ are isomorphic for all polynomials $A$.
\end{lemma}

\begin{proof}
If $A$ is constant then it follows from Lemma \ref{lem:colimcon}.
For the identity it is trivial, and for sums and products, it follows from Lemmata \ref{lem:colimsum} and \ref{lem:colimprod} respectively. 
\end{proof}

Now we will construct the map $A_{\rec} \> (\hocolim \> F \> f) \rightarrow \hocolim \> F \> f$, and by Lemma \ref{lem:colim_commute_poly} it suffices to make a map $\hocolim \> (A_{\rec} \comp F) \> (A_{\rec} \> f) \rightarrow \hocolim \> F \> f$.
For this we use the recursion rule of $\hocolim$, and we start with the following string of maps
\[
\xymatrix
{
                A_{\rec}(F \> n) \ar[r]^-{c_{\rec}'} 
                & H_{\rec}(F \> n) \ar[rr]^-{\term \comp \inn_2} &
                & H_{\Con}(F \> n) \ar[r]^-{\inC}
                & H_{\Approx}(F \> n) = F(n + 1)
}
\]
Composing this map with $\inc$, gives maps $A_{\rec}(F \> n) \rightarrow \hocolim \> F \> f$ for all $n : \mathbb{N}$.

Next we need to show the commutativity of the following triangle.
\[
\xymatrix
{
        A_{\rec}(F \> n) \ar[rr]^{A_{\rec}(f \> n)} \ar[dr] & & A_{\rec}(F(n+1)) \ar[dl] \\
        & \hocolim \> F \> f &
}
\]
Before we continue, let us recall that inductive types are functors.
Suppose, we have an inductive type $T$ with a parameter $P$, then a function $f : P \rightarrow Q$ gives a function $T \> f : T \> P \rightarrow T \> Q$.
Let us start with the following rectangle
\[
\xymatrix
{
        A_{\rec}(F \> n) \ar[r]^-{c_{\rec}'} \ar[d]_{A_{\rec}(f \> n)} 
                & H_{\rec}(F \> n) \ar[rr]^{\term \comp \inn_2} \ar[d]_{H_{\rec}(f \> n)} &
                & H_{\Con}(F \> n) \ar[d]_{H_{\Con}(f \> n)}\\
        A_{\rec}(F(n+1)) \ar[r]_-{c_{\rec}'} 
                & H_{\rec}(F(n+1)) \ar[rr]_{\term \comp \inn_2} &
                & H_{\Con}(F(n+1))
}
\]
The left square commutes, because by definition of $H_{\rec} \> f$ we have
\[
H_{\rec} \>(f \> n) \> (c_{\rec}' x) = c_{\rec}' (A_{\rec} \> (f \> n) \> x).
\]
For a similar reason, the right square commutes as well.
Hence, it suffices to show that the following diagram commutes.
\[
\xymatrix
{
        H_{\Con}(F \> n) \ar[d]_{H_{\Con} \> (f \> n)} \ar[r]^-{\inC}
                & F(n+1) \ar[d]^{f(n+1)}\\
        H_{\Con}(F(n+1)) \ar[r]_-{\inC}
                & H_{\Approx} \> (F(n+1))
}
\]
Note that $H_{\Approx}(F(n+1)) = F(n+2)$ and $H_{\Approx}(F \> n) = F(n+1)$.
Hence, this diagram commutes, because of the coherency added in $C_2$.

Next we need to define the introduction rules for the paths.
Let us start by extending the maps $t_i, r_i : B_i \> (\hocolim \> F \> f) \rightarrow \hocolim \> F \> f$.
Since homotopy colimits commute with polynomials, it suffices to make a map $\hocolim \> (B_i \> F) \> (B_i \> f)  \rightarrow \hocolim \> F \> f$, and for this we need to start by defining maps $B_i(F \> n) \rightarrow \hocolim \> F \> f$.
Note that by construction we always have maps $\overline{t_i}, \overline{r_i} : B_i(F \> n) \rightarrow H_{\Con}(F \> n)$, and thus we obtain maps $B_i(F \> n) \rightarrow F(n+1)$ by composing these with $\inC$.

Now we need to check the commutativity of the following diagram
\[
\xymatrix
{
        B_i(F \> n) 
        \ar[r]^-{\overline{t_i}} 
        \ar[d]_{B_i(f \> n)} 
        & 
        H_{\Con}(F \> n) 
        \ar[r]^-{\inC}
        \ar[d]^{H_{\Con}(f \> n)}  
        & 
        C_2(F \> n)
        \ar[r]^{\inC}
        & 
        F(n+1) 
        \ar[d]^{f \> n}\\
        B_i(F(n+1)) 
        \ar[r]_-{\overline{t_i}} 
        & 
        H_{\Con}(F(n+1)) 
        \ar[r]_-{\inC} 
        & 
        C_2(F(n+1))
        \ar[r]_{\inC} 
        & 
        F(n+2)
}
\]
The right rectangle commutes, because the maps $\inC$ are built by composing constructors of the coequalizer, and thus it commutes by definition.
Now it computes overall due to Lemma \ref{lem:constrCoh} which says that $\inC(\overline{t_i}(B_i(f \> n) \> x))$ and $\inC(H_{\Con}(f \> n)(\overline{t_i} \> x))$ are equal for all $x : B_i(F \> n)$.

In order to show that we indeed have paths $p_i$, we use the eliminator of the homotopy colimit.
We need to show that for all $x : \hocolim \> F \> f$ we have $t_i \> x = r_i \> x$. 
First, we need to give for all $x : F \> n$ an inhabitant of $t_i \> (\inc \> n \> x) = r_i \> (\inc \> n \> x)$.
By the first identification we have a path $\glueC \> x$ between $\overline{t_i} \> x$ and $\overline{r_i} \> x$, and thus the right path is $\ap \> (\inc \> n) \> (\glueC \> x)$. 

To finish the proof, we need to show that 
\[
(\com \> n \> x)_*(\ap \> (\inc \> n) \> (\glueC \> x)) = \ap \> (\inc \> (n+1)) \> (\glueC \> ((B_i \>(f \>n)) \> x)).
\]
This follows from the following computation.
\begin{equation*}
\begin{split}
\ap &\> (\inc \> (n+1)) \> (\glueC \> ((B_i \>(f \> n)) \> x))\\
&= \ap \> (\inc \> (n+1)) \> (\ap \> (f \> n) \>\glueC \> x))\\
&= \ap \> (\inc \> (n+1) \circ (f \> n)) \>\glueC \> x))\\
&=\com_* \> (\ap \> (\inc \> n) \> (\glueC \> x))
\end{split}
\end{equation*}
The first step follows from the third added coherency, the second from Lemma 2.2.2 in \cite{hottbook}, and the last step from Lemma \ref{lem:pathext}.


\subsection{Elimination Rule}
For the next step we define the right eliminator for $\hocolim \> F \> f$, so suppose that we are given the following data
\[
Y : \hocolim \> F \> f \rightarrow \Type,
\]
\[
c_{Y, \nonrec} : \prod (a : A_{\nonrec}), Y(c_{\nonrec} \> a),
\]
\[
c_{Y, \rec} : \prod (x : A_{\rec} \> \hocolim \> F \> f), \overline{A_{\rec}} \> Y \> x \rightarrow Y(c_{\rec} \> x),
\]
\[
q_{Y, i} : \prod (x : B_i \> H)(h_x : \overline{B_i} \> Y \> x), \hatt_i =_{p_j \, x} \hatr_j.
\]
In order to make a map $h : \prod (x : \hocolim \> F \> f), Y \> x$, we use the induction principle of $\hocolim \> F \> f$, and for that we first need to make maps $h \> n : \prod (x : F \> n), Y(\inc \> n \> x)$ for $n : \mathbb{N}$.

We start by making a map $h \> 0 : \prod (x : F \> 0), Y(\inc \> 0 \> x)$.
Recall that $F \> 0$ was defined to be $H_{\nonrec}$ which only has a constructor $c'_{\nonrec} : A_{\nonrec} \rightarrow H_{\nonrec}$.
So, let us assume that we have $a : A_{\nonrec}$.
Since $c_{\nonrec} \> a = \inc \> 0 \> (c_{\nonrec}' \> a)$, it suffices to find an inhabitant of $Y(c_{\nonrec} \> a)$, and for that we take $c_{Y, \nonrec} \> a$.
Hence, we get a map $h \> 0$.

Now suppose that we have a map $h \> n : \prod (x : F \> n), Y(\inc \> n \> x)$, and our goal is to make a map $h(n+1) : \prod  (x : F(n+1)), Y(\inc \> (n+1) \> x)$.
In order to do so, we will first look at how to extend $h \> n$ to a map $\prod (x : H_{\Con} (F \> n)), Y(\inc \> (n+1) \> (\inC \> x))$.

Let us do this in the general case.
Suppose, we have a map $g : P \rightarrow \hocolim \> F \> f$, and that we already constructed $\varphi : \prod (x : P), Y(g \> x)$.
Our goal is to extend the map into $\varphi' : \prod (x : H_{\rec} P), Y(c_{Y, \rec} \> x)$, and for that we use $H_{\rec}$-induction.
Note that for each $c'_{\rec} \> x$ with $x : A_{\rec} \> P$ we have the type $Y(c_{\rec} \> (A_{\rec} \> g \> x))$, and thus we have a type family on $H_{\rec}$.
Now let $x : A_{\rec} \> P$ and $y : \overline{A_{\rec}} \> Y \> x$ be given.
Then we need to give an element of the type $Y(c_{\rec} \> (A_{\rec} \> g \> x))$ for which we take $c_{Y,\rec} \> (A_{\rec} \> g \> x) \> y$.
We will often leave the argument $A_{\rec} \> g \> x$ implicit.

Now we can also extend the map to $H_{\Con}^n \> P$, because we can define this map on each component.
On the component $P$ it is just $\varphi$, and on the other components we define it via extension.
We call this map $h_1$.

Next we need to extend the map to $H_{\Approx}$.
This is done by the universal mapping property of the coequalizer, and that requires some steps.
First, to give an paths between the images of $t_i \> x$ and $r_i \> x$.
Note that the images of these are $\hatt_i \> x$ and $\hatr_i \> x$ respectively, and then $q_{Y, i}$ gives the desired paths.
This gives an extension $h_2$ to $C_1$.

Next we check the coherency conditions, and we start with the first.
We need to check that $\inn_1(\inC \> x)$ and $H_{\Con} \> \inC \> x$ get mapped to the same element for $x : H_{\Con}(F \> n)$ by $h_2$.
To do so, we use a case distinction on $H_{\Con}(F \> n)$, and for the case $x \equiv \inn_1 \> y$ with $y : F \> n$, we have the following equations 
\begin{equation*}
\begin{split}
h_2 \> (\inC(\inn_1(\inC \> (\inn_1 \> y))))
&\equiv 
h_1 \> (\inn_1(\inC(\inn_1 \> y))),
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
h_2 \> (\inC(H_{\Con} \> (\inC \circ \inn_1) \> (\inn_1 \> y)))
&\equiv
h_1 \> (H_{\Con} \> (\inC \circ \inn_1) \> (\inn_1 \> y))\\
&\equiv 
h_1 \> (\inn_1(\inC(\inn_1 \> y)))
\end{split}
\end{equation*}
Since they are definitionally equal, we can just use the path $\refl$.

For the other cases, we take a look at $c_{\rec}' \> y$, and for $y$ we assume that $h_1(\inn_1(\inC \> y)) = h_1(H_{\Con} \> (\inC \circ \inn_1) \> y)$.
Note that at each level $h$ is defined using the eliminator of the coequalizer.
This means that $h \> n \> (\inC \> (c_{\rec}' \> y))$ and $c_{Y, \rec}(h \> n \> (\inC \> y))$ are equal by definition, and thus we can make the following computations.
\begin{equation*}
\begin{split}
h_1 \> (\inn_1(\inC \> (c_{\rec}' \> y))) 
&\equiv 
h \> n \> (\inC \> (c_{\rec}' \> y))\\
&
= c_{Y, \rec} (h \> n \> (\inC \> y))
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
h_1 \> (H_{\Con} \> (\inC \circ \inn_1) \> (c_{\rec}' \> y)) 
&\equiv 
h_1 \> (c_{\rec}' \> (H_{\Con} \> (\inC \circ \inn_1) \> y))
\\
&\equiv
c_{Y, \rec} \> (h_1 \> (H_{\Con} \> (\inC \circ \inn_1) \> y))\\
&=
c_{Y, \rec} \> (h_1(\inn_1(\inC \> y)))\\
&\equiv
c_{Y, \rec} \> (h \> n \> (\inC \> y)).
\end{split}
\end{equation*}


For the second coherency we need to check that the paths $\ap \> h_2 \> (\ap \> (f \> n) \> (p_i \> x))$ and $\ap \> h_2 \> (p_i \> (f \> n \> x))$ are equal.
Here we use several Lemmata, namely Lemma 2.2.2 from \cite{hottbook} and Lemma \ref{lem:pathext}.
For the first path we can show that it is equal to $q_{Y, i} \> (h \> n \> x)$.
\begin{equation*}
\begin{split}
\ap \> h_2 \> (\ap \> (f \> n) \> (p_i \> x))
&\equiv
\ap \> h_2 \> (\ap \> (\inC \circ \inn_1) \> (p_i \> x))\\
&=
\ap \> (h_2 \circ \inC) \> (\ap \> \inn_1 \> (p_i \> x))\\
&=
\ap \> h_1 \> (\ap \> \inn_1 \> (p_i \> x))\\
&=
\ap \> (h_1 \circ \inn_1) \> \> (p_i \> x)\\
&=
\ap \> (h \> n) \> \> (p_i \> x)\\
&\equiv
q_{Y, i} \> (h \> n \> x)
\end{split}
\end{equation*}
Since $(h_2 \circ \inC) \> x \equiv h_1 \> x$ and $(h_1 \circ \inn_1) \> x \equiv h \> n \> x$, we can use the path $\refl$, and thus the transport is the identity.
For the other path we can do the same.
\begin{equation*}
\begin{split}
\ap \> h_2 \> (p_i \> (f \> n \> x))
&\equiv
q_{Y, i} \> (h_2 \> (f \> n \> x))\\
&\equiv
q_{Y, i} \> (h_2 \> (\inC \> \inn_1 \> x))\\
&\equiv
q_{Y, i} \> (h_1 \> (\inn_1 \> x))\\
&\equiv
q_{Y, i} \> (h \> n \> x)
\end{split}
\end{equation*}

To finish the proof, we need to give the image for the path $\com$.
More concretely, we need to show that $\inc \> n \> x$ and $\inc \> (n+1) \> (f \> x)$ are mapped to the same element.
The map $f : F \> n \rightarrow F(n + 1)$ is defined by the elimination rule of the coequalizer as follows
\[
\xymatrix
{
        F \> n \ar[r]^-{\inn_1} & H_{\Con} \> (F \> n) \ar[r]^-{\inC} & \ldots \ar[r]^-{\inC} & F(n+1)
}
\]
Since the map to $Y$ was defined via the universal property of the coequalizer, it will commute automatically.
The commutativity is given by the computation rule of the coequalizer.

All in all, we have acquired a map $\prod (x : \hocolim \> F \> f), Y \> x$, and this way we defined the right eliminator for $\hocolim \> F \> f$.
We shall call the eliminator $H\ind$.

\subsection{Computation Rules}
Lastly, we show that this eliminator also satisfies the computation rules.
First, we prove that for each $t : A_{\rec}(\hocolim \> F \> f)$ that $H\ind(c_{\rec} \> t) \equiv f_i \> t \> (\overline{A_{\rec}} \> H\ind \> t)$.
Again we use that colimits commute with polynomials.

Let $n : \mathbb{N}$ and $x : A_{\rec}(F \> n)$.
Now we can perform the computations in an intermediate stage of the construction, and using the computation rules we get
\begin{equation*}
\begin{split}
H\ind(c_{\rec} \> (\inc \> n \> x)) 
&\equiv H\ind(\inc \> (n+1) \> (c_{\rec}' x)) \\
&\equiv c_{Y,\rec} \> (A_{\rec} \> (\inc \> n) \> x) \> (\overline{A} \> H\ind \> x)
\end{split}
\end{equation*}
Hence, we can always take $\refl$ to be the path.
This will also give an image for $\com$, and thus the computation rules for the points are satisfied.

Note that the this computation rule is a propositional equality.
This is logical, because it is proven all $x : A_{\rec}(F \> n)$.
However, for terms built from $c_{\nonrec}$ and $c_{\rec}$, we have a definitional equality.
This is because $c_{\nonrec} \> a$ for $a : A_{\nonrec}$ is defined to be $\inc \> 0 \> (c_{\nonrec}' \> a)$.
All the closed terms are thus inhabitants of some $F \> n$, and since at every step the equalities are definitional, we can conclude that for closed terms the equality is definitional.

Now we show the computation rules for the paths, and in that case we have a parameter $a : B_i \> (\hocolim \> F \> f)$.
By using that polynomials commute with homotopy colimits, we can again assume that we have $n : \mathbb{N}$ and $x : B_i(F \> n)$.
\begin{equation*}
\begin{split}
\apd \> H\ind \> (p_i \> (\inc \> n \> x))
&\equiv \apd \> H\ind \> (\ap \> (\inc \> (n+1)) \> \glueC \> x)\\
&= \apd \> (H\ind \comp  \> \inc (n+1)) \> (\glueC \> x)\\
&= \apd \> (h \> n) \> (\glueC \> x)\\
&\equiv q_i \> (B_i \> H\frec \> x)
\end{split}
\end{equation*}


\section{Lemmata}
\label{sec:Lemmata}
\begin{lemma}
\label{lem:constrTerm}
Suppose, we have a constructor term $t$ such that $x : F \> T \vdash t : G \>T$ which uses at most $n$ constructors, and that we have a map $c_{\nonrec}' : A_{\nonrec} \rightarrow P$.
Then $t$ induces a map $\overline{t} : F \> P \rightarrow H_{\Con}^n \> (G \> P)$ by replacing the constructors $c_{\nonrec}$ and $c_{\rec}$ by $c_{\nonrec}'$ and $c_{\rec}'$ respectively.
\end{lemma}

\begin{proof}
We use induction on the form of the constructor term.
\begin{itemize}
        \item $t = a$ with $a : B$ and $B$ does not use $T$. Then we define $\overline{t} \> y = \inn_1 \> a$.
        \item $t = x$ with $x : F \> T$. Then we define $\overline{t} \> y = \inn_1 \> y$.
        \item $t = c_{\nonrec} \> a$ with $a : A_{\nonrec}$. Then we define $\overline{t} \> y = \inn_1 \> (c_{\nonrec}' \> a)$.
        \item $t = c_{\rec} \> r$ with $r : A_{\rec} \> T$ where $r$ uses at most $n-1$ constructors. 
        By induction we have a map $\overline{r} : F \> P \rightarrow A_{\rec} \> H_{\Con}^{n-1}$.
        Then we define $\overline{t} \> y = c_{\rec}' (\overline{r} \> x)$.
        \item For the rules for the projection, pairing and injection it is trivial. \qedhere
\end{itemize}
\end{proof}

\begin{lemma}
\label{lem:constrCoh}
Suppose, we have a constructor term $t$ such that $x : F \> T \vdash t : G \> T$ which uses at most $n$ constructors, and that we have a map $c_{\nonrec}' : A_{\nonrec} \rightarrow Q$.
Furthermore, we assume that we have a map $f : Q \rightarrow P$
Then for all $x : F \> P$ the terms $\overline{t}(F \> f \> x)$ and $(H_{\Con} \circ G) \> f \> (\overline{t} \> x)$ are equal.
\end{lemma}

\begin{proof}
Again we use induction on the constructor term.
\begin{itemize}
        \item $t = a$ with $a : B$ and $B$ does not use $T$. 
        Then we have $G \> P = B$, and thus 
        $
        \overline{t}(F \> f \> x) = a.
        $
        On the other hand, we have, 
        \[
        (H_{\Con} \circ G) \> f \> (\overline{t} \> x) = G \> f \> a = a.
        \]
        \item $t = x$ with $x : F \> T$. 
        Then $G \> P = F \> P$, and thus
        $
        \overline{t}(F \> f \> x) = \inn_1(F \> f \> x).
        $
        Also,
        \[
        (H_{\Con} \circ G) \> f \> (\overline{t} \> x) = (H_{\Con} \circ G) \> f \> (\inn_1 \> x) = \inn_1(G \> f \> x) = \inn_1(F \> f \> x).
        \]
        \item $t = c_{\nonrec} \> a$ with $a : A_{\nonrec}$. 
        Then $G \> P = P$, and thus
        $
        \overline{t}(F \> f \> x) = \inn_1(f(c'_{\nonrec} \> a))
        $.
        Also,
        \[
        (H_{\Con} \circ G) \> f \> (\overline{t} \> x) = H_{\Con} \> f \> (\inn_1(c'_{\nonrec} \> a)) = \inn_1(f(c'_{\nonrec} \> a))
        \]
        \item $t = c_{\rec} \> r$ with $r : A_{\rec} \> T$ where $r$ uses at most $n-1$ constructors. 
        The induction hypothesis in this case is that $H_{\Con} \> f \> (\overline{r} \> x) = \overline{r}(F \> f \> x)$.
        Then again $G \> P = P$, and thus
        $
        \overline{t}(F \> f \> x) = c'_{\rec} \> (\overline{r}(F \> f \> x))
        $.
        Furthermore,
        \[
        (H_{\Con} \circ G) \> f \> (\overline{t} \> x) = H_{\Con} \> f \> (c'_{\rec} \> (\overline{r} \> x)) = c'_{\rec} \> (H_{\Con} \> f \> (\overline{r} \> x)) = c'_{\rec} \> (\overline{r}(F \> f \> x))
        \]
        \item For the rules for the projection, pairing and injection it is trivial. \qedhere
\end{itemize}
\end{proof}

\begin{lemma}
\label{lem:colimcon}
The type $\hocolim \> (\lambda n . A) \> (\lambda n . \operatorname{Id})$ is isomorphic to $A$.
\end{lemma}

\begin{proof}
We define the map $f : A \rightarrow \hocolim \> (\lambda n . A) \> (\lambda n . \operatorname{Id})$
to be $\inc \> 0$.
Next we define $g : \hocolim \> (\lambda n . A) \> (\lambda n . \operatorname{Id}) \rightarrow A$ by $\hocolim$ recursion.
We send $\inc \> n \> a$ to $a$, and then the required diagrams commute by reflexivity.
The proof that these maps are mutual inverses is straightforward but tedious, so we refer the reader to the accompanying Coq code \cite{CoqImpl}.
\end{proof}

\begin{lemma}
\label{lem:colimsum}
Colimits commute with coproducts, so $\hocolim \> (G_1 + G_2) \> (g_1 + g_2)$ and $\hocolim \> G_1 \> g_1 + \hocolim \> G_2 \> g_2$ are isomorphic.
\end{lemma}

\begin{proof}
This one is not difficult either, so we will be brief and refer the reader to \cite{CoqImpl} for details.
We start by making a map 
\[
\hocolim \> (G_1+G_2) \> (g_1 + g_2) \rightarrow \hocolim \> G_1 \> g_1 + \hocolim \> G_2 \> g_2.
\]
This map is defined by recursion over the colimit, so take any $n : \mathbb{N}$ and $x : G_i \> n$.
Then the image of $\inc \> n \> (\inn_i \> x)$ is defined to be $\inn_i (\inc \> n \> x)$, and the image of $\com \> n \> (\inn_i \> x)$ is defined by
$\ap \> \inn_i \> (\com \> G_i \> g_i \> n \> x)$.

For the map in the other direction, we need to make 
\[
\hocolim \> G_i \> g_i \rightarrow \hocolim \> (G_1 + G_2) \> (g_1 + g_2).
\]
We send $\inc \> n \> x$ to $\inc \> n \> (\inn_i \> x)$ and $\com \> n \> x$ to $\com \> n \> (\inn_i \> x)$.
\end{proof}

\begin{lemma}
\label{lem:colimprod}
Colimits commute with products.
\end{lemma}

\begin{proof}
This follows from a more general result which says that colimits commute with sigma types which is proven in \cite{boulier2015colimites,boulier2016} under `commutation with sigmas'.
\end{proof}

\begin{lemma}
\label{lem:pathext}
Given are types $A, B$ and functions $f, g : A \rightarrow B$ such that we have an inhabitant $e : f = g$.
Furthermore, assume that we have a path $p : x = y$ where $x$ and $y$ are terms of type $A$.
Then for all we have a path
\[
e_* \> (\ap \> f \> p) = \ap \> g \> p.
\]
All in all, we have an inhabitant of the type
\[
\prod (f, g : A \rightarrow B) (e : f = g) (x, y : A) (p : x = y), e_* \> (\ap \> f \> p) = \ap \> g \> p
\]
where $A, B : \Type$.
\end{lemma}

\begin{proof}
Since this statement is universally quantified over $p$, we can apply path induction.
Assuming $p$ to be $\refl$, the map $e_*$ is the identity, and in that case it holds.
Hence, it follows by path induction.
\end{proof}

\begin{lemma}
\label{lem:funTrans}
Again we are given types $A, B$, functions $f, g : A \rightarrow B$, an inhabitant $e : f = g$, and a path $p : f \> x = f \> y$ with $x, y : A$.
Then we have a path 
\[
e_* \> p = (e \fpath x)^{-1} \conc p \conc (e \fpath x)
\]
Formally, this means that for $A, B : \Type$ we have an inhabitant of the type
\[
\prod (f, g : A \rightarrow B) (e : f = g) (x, y : A) (p : f \> x = f \> y), e_* \> p = (e \fpath x)^{-1} \conc p \conc (e \fpath y).
\]
\end{lemma}

\begin{proof}
Again we use path induction on $e$, so we assume that $e = \refl$.
Then $e \fpath x = \refl$ and $e \fpath y = \refl$, so the right side is equal to $p$.
Also, in this case $e_*$ is the identity map, so the left side also is $p$.
\end{proof}

\section{Conclusion and Further Work}

MOVED FROM BEGINNING: A possible extension would be to use arbitrary containers as in \cite{abbott2005containers}, but we shall refrain to do so.
With that extension the given proof requires the axiom of choice which generally does not hold in type theory.


Higher inductive types can thus be constructed if we have the interval, homotopy pushout and homotopy colimits.
Since the construction is done in homotopy type theory without assuming extra axioms, the proof is constructive.
Notice that the only inductive types we needed were the sum and product types rather than the general class of W-types or those described inductive schemes.
Hence, we can also deduce the existence of all inductive types from this theorem if we just have sums, products, and the three HITs. 

There is still some work which remains to be done.
First of all, we expect that this theorem will have applications in the semantics and the metatheory of higher inductive types.
There are already several interpretations of homotopy type theory in abstract homotopy theory \cite{arndt2011homotopy,awodey2009homotopy,bezem2014model,cohen2016cubical,kapulkin2012simplicial}.
Rather than using the full-blown definition one could instead just look at a small number of cases, and that could simplify checking whether all higher inductive types exist in some model.
Also, the theorem could also be used for generic programming with higher inductive types \cite{altenkirch2003generic}.
If we know how a function is defined for the interval, the homotopy pushout, and the homotopy colimit, then we know how it is defined for all higher inductive types.

Furthermore, there might be some interesting theoretical possibilities for the Three-HITs Theorem.
We expect that it can be generalized if a syntax of higher inductive types with a higher dimensional paths is given.
If constructor terms are used, then most of the proof might even be reusable.

The work of Sojakova \cite{sojakova2015higher} relates higher inductive types to homotopy initial algebra.
Since initial algebra are made as a colimit, it could be that this construction and homotopy initial algebras are related in some way.
Also, the work by Altenkirch et al. \cite{altenkirch2016quotient} allows more general constructors which is not allowed in the syntax used in this paper.
If the proof can be extended somehow to also allows these constructors, then that would pave the way towards constructive semantics of QIITs.

%\nocite{*}

%%
%% Bibliography
%%

%% Either use bibtex (recommended), 

\bibliography{Paper}

%% .. or use the thebibliography environment explicitely



\end{document}
